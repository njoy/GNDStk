
!! THIS FILE WAS AUTOGENERATED!
!! DO NOT MODIFY!

module generalLs
use iso_c_binding
interface


!! -----------------------------------------------------------------------------
!! Basics
!! Create, Assign, Delete
!! -----------------------------------------------------------------------------

!! Create, default, const
function LsDefaultConst() &
      bind(C, name='LsDefaultConst')
   use iso_c_binding
   implicit none
   type(c_ptr) :: LsDefaultConst
end function LsDefaultConst

!! Create, default, non-const
function LsDefault() &
      bind(C, name='LsDefault')
   use iso_c_binding
   implicit none
   type(c_ptr) :: LsDefault
end function LsDefault

!! Create, general, const
function LsCreateConst( &
   L, LSize &
) &
      bind(C, name='LsCreateConst')
   use iso_c_binding
   implicit none
   integer(c_size_t), intent(in), value :: LSize
   type(c_ptr), intent(in) :: L(LSize)
   type(c_ptr) :: LsCreateConst
end function LsCreateConst

!! Create, general, non-const
function LsCreate( &
   L, LSize &
) &
      bind(C, name='LsCreate')
   use iso_c_binding
   implicit none
   integer(c_size_t), intent(in), value :: LSize
   type(c_ptr), intent(in) :: L(LSize)
   type(c_ptr) :: LsCreate
end function LsCreate

!! Assign
subroutine LsAssign(handleLHS, handleRHS) &
      bind(C, name='LsAssign')
   use iso_c_binding
   implicit none
   type(c_ptr), value :: handleLHS
   type(c_ptr), intent(in), value :: handleRHS
end subroutine LsAssign

!! Delete
subroutine LsDelete(handle) &
      bind(C, name='LsDelete')
   use iso_c_binding
   implicit none
   type(c_ptr), value :: handle
end subroutine LsDelete


!! -----------------------------------------------------------------------------
!! I/O
!! Read, Write, Print
!! Each returns 0 if failure, 1 if success.
!! -----------------------------------------------------------------------------

!! Read from file
!! File can be XML, JSON, or HDF5.
!! We'll examine the file's contents to determine its type automatically.
function LsRead(handle, filename, filenameSize) &
      bind(C, name='LsRead')
   use iso_c_binding
   implicit none
   type(c_ptr), value :: handle
   integer(c_size_t), intent(in), value :: filenameSize
   character(c_char), intent(in) :: filename(filenameSize)
   integer(c_int) :: LsRead
end function LsRead

!! Write to file
!! File can be XML, JSON, or HDF5.
!! We'll use filename's extension to determine the type you want written.
function LsWrite(handle, filename, filenameSize) &
      bind(C, name='LsWrite')
   use iso_c_binding
   implicit none
   type(c_ptr), intent(in), value :: handle
   integer(c_size_t), intent(in), value :: filenameSize
   character(c_char), intent(in) :: filename(filenameSize)
   integer(c_int) :: LsWrite
end function LsWrite

!! Print to standard output, in our prettyprinting format
function LsPrint(handle) &
      bind(C, name='LsPrint')
   use iso_c_binding
   implicit none
   type(c_ptr), intent(in), value :: handle
   integer(c_int) :: LsPrint
end function LsPrint

!! Print to standard output, as XML
function LsPrintXML(handle) &
      bind(C, name='LsPrintXML')
   use iso_c_binding
   implicit none
   type(c_ptr), intent(in), value :: handle
   integer(c_int) :: LsPrintXML
end function LsPrintXML

!! Print to standard output, as JSON
function LsPrintJSON(handle) &
      bind(C, name='LsPrintJSON')
   use iso_c_binding
   implicit none
   type(c_ptr), intent(in), value :: handle
   integer(c_int) :: LsPrintJSON
end function LsPrintJSON


!! -----------------------------------------------------------------------------
!! Child: L
!! -----------------------------------------------------------------------------

!! Has
function LsLHas(handle) &
      bind(C, name='LsLHas')
   use iso_c_binding
   implicit none
   type(c_ptr), intent(in), value :: handle
   integer(c_int) :: LsLHas
end function LsLHas

!! Clear
subroutine LsLClear(handle) &
      bind(C, name='LsLClear')
   use iso_c_binding
   implicit none
   type(c_ptr), value :: handle
end subroutine LsLClear

!! Size
function LsLSize(handle) &
      bind(C, name='LsLSize')
   use iso_c_binding
   implicit none
   type(c_ptr), intent(in), value :: handle
   integer(c_size_t) :: LsLSize
end function LsLSize

!! Add
subroutine LsLAdd(handle, fieldHandle) &
      bind(C, name='LsLAdd')
   use iso_c_binding
   implicit none
   type(c_ptr), value :: handle
   type(c_ptr), intent(in), value :: fieldHandle
end subroutine LsLAdd

!! Get, by index \in [0,size), const
function LsLGetConst(handle, index) &
      bind(C, name='LsLGetConst')
   use iso_c_binding
   implicit none
   type(c_ptr), intent(in), value :: handle
   integer(c_size_t), intent(in), value :: index
   type(c_ptr) :: LsLGetConst
end function LsLGetConst

!! Get, by index \in [0,size), non-const
function LsLGet(handle, index) &
      bind(C, name='LsLGet')
   use iso_c_binding
   implicit none
   type(c_ptr), value :: handle
   integer(c_size_t), intent(in), value :: index
   type(c_ptr) :: LsLGet
end function LsLGet

!! Set, by index \in [0,size)
subroutine LsLSet(handle, index, fieldHandle) &
      bind(C, name='LsLSet')
   use iso_c_binding
   implicit none
   type(c_ptr), value :: handle
   integer(c_size_t), intent(in), value :: index
   type(c_ptr), intent(in), value :: fieldHandle
end subroutine LsLSet

!! ------------------------
!! Re: metadatum label
!! ------------------------

!! Has, by label
function LsLHasByLabel(handle, meta, metaSize) &
      bind(C, name='LsLHasByLabel')
   use iso_c_binding
   implicit none
   type(c_ptr), intent(in), value :: handle
   integer(c_size_t), intent(in), value :: metaSize
   character(c_char), intent(in) :: meta(metaSize)
   integer(c_int) :: LsLHasByLabel
end function LsLHasByLabel

!! Get, by label, const
function LsLGetByLabelConst(handle, meta, metaSize) &
      bind(C, name='LsLGetByLabelConst')
   use iso_c_binding
   implicit none
   type(c_ptr), intent(in), value :: handle
   integer(c_size_t), intent(in), value :: metaSize
   character(c_char), intent(in) :: meta(metaSize)
   type(c_ptr) :: LsLGetByLabelConst
end function LsLGetByLabelConst

!! Get, by label, non-const
function LsLGetByLabel(handle, meta, metaSize) &
      bind(C, name='LsLGetByLabel')
   use iso_c_binding
   implicit none
   type(c_ptr), value :: handle
   integer(c_size_t), intent(in), value :: metaSize
   character(c_char), intent(in) :: meta(metaSize)
   type(c_ptr) :: LsLGetByLabel
end function LsLGetByLabel

!! Set, by label
subroutine LsLSetByLabel(handle, meta, metaSize, fieldHandle) &
      bind(C, name='LsLSetByLabel')
   use iso_c_binding
   implicit none
   type(c_ptr), value :: handle
   integer(c_size_t), intent(in), value :: metaSize
   character(c_char), intent(in) :: meta(metaSize)
   type(c_ptr), intent(in), value :: fieldHandle
end subroutine LsLSetByLabel

!! ------------------------
!! Re: metadatum value
!! ------------------------

!! Has, by value
function LsLHasByValue(handle, meta) &
      bind(C, name='LsLHasByValue')
   use iso_c_binding
   implicit none
   type(c_ptr), intent(in), value :: handle
   integer(c_int), intent(in), value :: meta
   integer(c_int) :: LsLHasByValue
end function LsLHasByValue

!! Get, by value, const
function LsLGetByValueConst(handle, meta) &
      bind(C, name='LsLGetByValueConst')
   use iso_c_binding
   implicit none
   type(c_ptr), intent(in), value :: handle
   integer(c_int), intent(in), value :: meta
   type(c_ptr) :: LsLGetByValueConst
end function LsLGetByValueConst

!! Get, by value, non-const
function LsLGetByValue(handle, meta) &
      bind(C, name='LsLGetByValue')
   use iso_c_binding
   implicit none
   type(c_ptr), value :: handle
   integer(c_int), intent(in), value :: meta
   type(c_ptr) :: LsLGetByValue
end function LsLGetByValue

!! Set, by value
subroutine LsLSetByValue(handle, meta, fieldHandle) &
      bind(C, name='LsLSetByValue')
   use iso_c_binding
   implicit none
   type(c_ptr), value :: handle
   integer(c_int), intent(in), value :: meta
   type(c_ptr), intent(in), value :: fieldHandle
end subroutine LsLSetByValue


!! -----------------------------------------------------------------------------
!! -----------------------------------------------------------------------------

end interface
end module generalLs
