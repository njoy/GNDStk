
#define CATCH_CONFIG_MAIN

#include "catch.hpp"
#include "proto/v1.9/containers/Values.hpp"

// other includes

// convenience typedefs
using namespace njoy::GNDStk;
using namespace proto;

using Values = v1_9::containers::Values;

std::string chunk();
std::string chunkInts();
std::string chunkStrings();
void verifyChunk( const Values& );
void verifyChunkInts( const Values& );
void verifyChunkStrings( const Values& );
std::string invalidName();

SCENARIO( "Values" ) {

  GIVEN( "valid data for the component - doubles" ) {

    std::string string = chunk();

    WHEN( "autogenerated constructor: the data are given explicitly" ) {

      std::vector< double > values = { 2500., 8.9172, 2550., 8.9155 };

      Values chunk( values );

      THEN( "the component can be constructed and members can be tested" ) {

        verifyChunk( chunk );
      } // THEN

      THEN( "it can be written in XML" ) {

        std::ostringstream out;
        XML( Node( chunk ) ).write( out, false );

        CHECK( out.str() == string );
      } // THEN
    } // WHEN

    WHEN( "the data are constructed from a node" ) {

      Node node;
      node << chunk();
      Values chunk( node );

      THEN( "the component can be constructed and members can be tested" ) {

        verifyChunk( chunk );
      } // THEN

      THEN( "it can be written in XML" ) {

        std::ostringstream out;
        XML( Node( chunk ) ).write( out, false );

        CHECK( out.str() == string );
      } // THEN
    } // WHEN
  } // GIVEN

  GIVEN( "valid data for the component - ints" ) {

    std::string string = chunkInts();

    WHEN( "autogenerated constructor: the data are given explicitly" ) {

      std::vector< Integer32 > values = { 2500, 9, 2550, 9 };

      Values chunk( values );

      THEN( "the component can be constructed and members can be tested" ) {

        verifyChunkInts( chunk );
      } // THEN

      THEN( "it can be written in XML" ) {

        std::ostringstream out;
        XML( Node( chunk ) ).write( out, false );

        CHECK( out.str() == string );
      } // THEN
    } // WHEN

    WHEN( "the data are constructed from a node" ) {

      Node node;
      node << chunkInts();
      Values chunk( node );

      THEN( "the component can be constructed and members can be tested" ) {

        verifyChunkInts( chunk );
      } // THEN

      THEN( "it can be written in XML" ) {

        std::ostringstream out;
        XML( Node( chunk ) ).write( out, false );

        CHECK( out.str() == string );
      } // THEN
    } // WHEN
  } // GIVEN

  GIVEN( "valid data for the component - strings" ) {

    std::string string = chunkStrings();

    WHEN( "autogenerated constructor: the data are given explicitly" ) {

      std::vector< UTF8Text > values = { "2500", "8.9172", "2550", "8.9155" };

      Values chunk( values );

      THEN( "the component can be constructed and members can be tested" ) {

        verifyChunkStrings( chunk );
      } // THEN

      THEN( "it can be written in XML" ) {

        std::ostringstream out;
        XML( Node( chunk ) ).write( out, false );

        CHECK( out.str() == string );
      } // THEN
    } // WHEN

    WHEN( "the data are constructed from a node" ) {

      Node node;
      node << chunkStrings();
      Values chunk( node );

      THEN( "the component can be constructed and members can be tested" ) {

        verifyChunkStrings( chunk );
      } // THEN

      THEN( "it can be written in XML" ) {

        std::ostringstream out;
        XML( Node( chunk ) ).write( out, false );

        CHECK( out.str() == string );
      } // THEN
    } // WHEN
  } // GIVEN

  GIVEN( "a valid component instance" ) {

    WHEN( "the component is copied" ) {

      Node node;
      node << chunk();
      Values chunk( node );

      // copy constructor
      Values copy( chunk );

      // copy assignment
      Values assign;
      assign = chunk;

      THEN( "the component can be constructed and members can be tested" ) {

        verifyChunk( copy );
        verifyChunk( assign );
      } // THEN
    } // WHEN

    WHEN( "the data are moved" ) {

      Node node;
      node << chunk();
      Values chunk( node );
      Values chunk2( node );

      // move constructor
      Values move( std::move( chunk ) );

      // move assignment
      Values assign;
      assign = std::move( chunk2 );

      THEN( "the component can be constructed and members can be tested" ) {

        verifyChunk( move );
        verifyChunk( assign );
      } // THEN
    } // WHEN
  } // GIVEN

  GIVEN( "invalid data" ) {

    WHEN( "when the wrong node is used" ) {

      Node node;
      node << invalidName();

      THEN( "an exception is thrown" ) {

        CHECK_THROWS( Values( node ) );
      } // THEN
    } // WHEN
  } // GIVEN
} // SCENARIO

std::string chunk() {

  return
R"***(<values valueType="Float64" start="0" length="4">2500 8.9172 2550 8.9155</values>)***";
}

void verifyChunk( const Values& component ) {

  CHECK( 4 == component.length() );
  CHECK( 0 == component.start() );
  CHECK( "Float64" == component.valueType().value() );

  CHECK( 4 == component.size() );
  CHECK( 4 == component.doubles().size() );

  CHECK( 2500. == Approx( component.doubles()[0] ) );
  CHECK( 8.9172 == Approx( component.doubles()[1] ) );
  CHECK( 2550. == Approx( component.doubles()[2] ) );
  CHECK( 8.9155 == Approx( component.doubles()[3] ) );
}

std::string chunkInts() {

  return
R"***(<values valueType="Integer32" start="0" length="4">2500 9 2550 9</values>)***";
}

void verifyChunkInts( const Values& component ) {

  CHECK( 4 == component.length() );
  CHECK( 0 == component.start() );
  CHECK( "Integer32" == component.valueType().value() );

  CHECK( 4 == component.size() );
  CHECK( 4 == component.ints().size() );

  CHECK( 2500 == component.ints()[0] );
  CHECK( 9 == component.ints()[1] );
  CHECK( 2550 == component.ints()[2] );
  CHECK( 9 == component.ints()[3] );
}

std::string chunkStrings() {

  return
R"***(<values valueType="UTF8Text" start="0" length="4">2500 8.9172 2550 8.9155</values>)***";
}

void verifyChunkStrings( const Values& component ) {

  CHECK( 4 == component.length() );
  CHECK( 0 == component.start() );
  CHECK( "UTF8Text" == component.valueType().value() );

  CHECK( 4 == component.size() );
  CHECK( 4 == component.strings().size() );

  CHECK( "2500" == component.strings()[0] );
  CHECK( "8.9172" == component.strings()[1] );
  CHECK( "2550" == component.strings()[2] );
  CHECK( "8.9155" == component.strings()[3] );
}

std::string invalidName() {

  // wrong name for the node
  return
R"***(<wrongName valueType="Float64" start="0" length="4">2500 8.9172 2550 8.9155</wrongName>)***";
}
