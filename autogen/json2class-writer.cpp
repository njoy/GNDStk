
// Comment-related markup...

// ...For C++
const auto largeComment = "// " + std::string(77,'-');
const auto smallComment = "// " + std::string(24,'-');

// ...For Fortran 2003
// ...Needs just one !, but we'll use two, for more uniformity with C++)
const auto largeFortran = "!! " + std::string(77,'-');
const auto smallFortran = "!! " + std::string(24,'-');


// -----------------------------------------------------------------------------
// writer
// -----------------------------------------------------------------------------

class writer {
   std::ostream &s;
   std::ofstream fstream;
   std::ostringstream sstream;

   static inline const char substitute = '@';
   static inline const int indent = 3;
   static inline const std::string message1 = "THIS FILE WAS AUTOGENERATED!\n";
   static inline const std::string message2 = "DO NOT MODIFY!\n";

   // recurse is used to prevent multiple reports of equivalent errors
   // as we step through the format string and arguments while printing.
   static int recurse;

   // checkArgs
   template<class T, class... Ts>
   void checkArgs(const std::string &str, const T &value, Ts &&...args)
   {
      if (recurse == 0) {
         using last = decltype(
            std::get<sizeof...(args)>(std::make_tuple(value,args...)));
         const size_t nsub = std::count(str.begin(),str.end(),substitute);
         // a bool last argument is not interpreted as an argument to print...
         const size_t narg =
            1 + sizeof...(args) - std::is_same_v<std::decay_t<last>,bool>;
         if (narg != nsub) {
            log::error(
               "Number of '{}' substitution characters and arguments "
               "don't match:\n"
               "writer(\"{}\", ...)", substitute, str);
            throw std::exception{};
         }
      }
   }

   // construct
   void construct(const bool autogen, const std::string &comment) const
   {
      if (autogen)
         s << "\n"
           << comment << ' ' << message1
           << comment << ' ' << message2;
   }

public:

   // writer()
   // Use a string stream
   explicit writer(
      const bool autogen = true, const std::string &comment = "//"
   ) :
      s(sstream)
   {
      construct(autogen,comment);
   }

   // writer(file)
   // Use a file stream
   explicit writer(
      const std::string &file,
      const bool autogen = true, const std::string &comment = "//"
   ) :
      s(fstream), fstream(file)
   {
      construct(autogen,comment);
   }

   // str()
   std::string str() const
   {
      if (&s != &sstream) {
         log::error(
            "writer.str() is available only for a writer "
            "that was default constructed"
         );
         throw std::exception{};
      }
      return sstream.str();
   }

   // ------------------------
   // operator()
   // ------------------------

   // char* cases are needed in addition to std::string, for disambiguation.
   // level is the indentation level.

   // operator()(string, newline)
   template<class T = bool, class = std::enable_if_t<std::is_same_v<T,bool>>>
   void operator()(const std::string &str = "", const T newline = true)
   {
      s << str;
      if (newline)
         s << std::endl;
   }

   template<class T, class = std::enable_if_t<std::is_same_v<T,bool>>>
   void operator()(
      const char *const str, const T newline = true
   ) {
      operator()(std::string(str), newline);
   }

   // operator()(level, string, newline)
   void operator()(
      const int level, const std::string &str = "", const bool newline = true
   ) {
      operator()(std::string(level*indent,' ') + str, newline);
   }

   void operator()(
      const int level, const char *const str, const bool newline = true
   ) {
      operator()(level, std::string(str), newline);
   }

   // operator()(string, value, args)
   template<
      class T, class... Ts,
      class = std::enable_if_t<!std::is_same_v<T,bool>>
   >
   void operator()(const std::string &str, const T &value, Ts &&...args)
   {
      checkArgs(str, value, std::forward<Ts>(args)...);
      recurse++;
      for (const auto &ch : str)
         if (ch != substitute)
            s << ch;
         else {
            s << value;
            operator()(std::string(&ch+1), std::forward<Ts>(args)...);
            break;
         }
      recurse--;
   }

   // operator()(level, string, value, args)
   template<
      class T, class... Ts,
      class = std::enable_if_t<!std::is_same_v<T,bool>>
   >
   void operator()(
      const int level, const std::string &str, const T &value, Ts &&...args
   ) {
      checkArgs(str, value, std::forward<Ts>(args)...);
      recurse++;
      operator()(
         std::string(level*indent,' ') + str,
         value,
         std::forward<Ts>(args)...
      );
      recurse--;
   }
};

int writer::recurse = 0;


// -----------------------------------------------------------------------------
// Helpers
// -----------------------------------------------------------------------------

// section
template<class... Ts>
void section(writer &out, const std::string &str, Ts &&...args)
{
   out();
   out();
   out(largeComment);
   out(str, std::forward<Ts>(args)...);
   out(largeComment);
}

// sectionFortran
template<class... Ts>
void sectionFortran(writer &out, const std::string &str, Ts &&...args)
{
   out();
   out();
   out(largeFortran);
   out(str, std::forward<Ts>(args)...);
   out(largeFortran);
}
