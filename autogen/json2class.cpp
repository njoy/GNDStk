
// -----------------------------------------------------------------------------
// Tool for autogenerating GNDStk classes from JSON specifications
// -----------------------------------------------------------------------------

#include "GNDStk.hpp"
#include <cstring>

using namespace njoy::GNDStk;

// Report cases of nodes that have no metadata, and zero or one child node(s).
// Where these exist, a simplification of the spec may be worth considering.
const bool singletons = true;

// Extra debug/informational printing?
const bool debugging = false;

// Put print statements in constructor and assignment calls. For debugging.
const bool printCtorCalls = false;

// Shortcut levels to utilize
// 0 = all
// 1 = none (child nodes are already there, by definition)
// 2 = to grandchildren
// 3 = to great-grandchildren
// ...
const int ShortcutLevels = 3;


// -----------------------------------------------------------------------------
// Data structures
// -----------------------------------------------------------------------------

// NamespaceAndClass
struct NamespaceAndClass {
   std::string nsname; // name of a namespace
   std::string clname; // name of a class in the namespace

   NamespaceAndClass(const std::string &ns = "", const std::string &cl = "") :
      nsname(ns), clname(cl)
   { }

   bool operator==(const NamespaceAndClass &other) const
   {
      return nsname == other.nsname && clname == other.clname;
   }

   bool operator<(const NamespaceAndClass &other) const
   {
      return
         nsname < other.nsname ? true
       : other.nsname < nsname ? false
       : clname < other.clname;
   }
};

// Class2Dependencies
// For a {namespace,class}, its {namespace,class} dependencies
struct Class2Dependencies {
   NamespaceAndClass theClass;
   std::vector<NamespaceAndClass> dependencies;
};

// InfoMetadata
struct InfoMetadata {
   // A JSON spec can make a metadatum be:
   //    - an optional, or
   //    - a Defaulted
   // but (in contrast with child nodes) can't make it be a vector of metadata.
   // An individual metadatum may be a vector in its own right, as in an XML
   // construct such as <element meta="1 2 3 4"> (so that meta is a vector of
   // integers). We mean here that there isn't a vector of such [meta] entries,
   // and there shouldn't be (XML wouldn't allow it).
   std::string original; // without e.g. the "double" to "Double" change
   std::string name;
   std::string converter;// converter: callable w/operator() string to/from type
   std::string type;     // underlying type
   std::string typeFull; // WITH any optional<> or Defaulted<>
   bool        isOptional;
   // todo Process and use the following - isVector - in order to properly
   // create C interface functions in the event that metadata are vectors.
   // For instance, a metadatum like size="10 20 30" might be something we'd
   // want to implement as a std::vector<int>. In this case, we'd probably
   // want the C interface to have an int* and a size. At the moment, in its
   // current form, the "C interface" generated by the code generator would
   // end up using "std::vector<int>" in the C functions, and that won't
   // actually work if somebody tried to compile them. (C doesn't know about
   // C++ classes.) Elsewhere in the code generator (see later in this file),
   // the mtype_param() and mtype_return() functions essentially recognize
   // std::string and transform it to char* for the C interface. Basically,
   // the point here is that we need to make the transformation more general.
   // It would be impossible to absolutely know, for any old arbitrary C++
   // type that somebody *could* use for a metadatum, how to do something
   // sensible in C (unless we just used a generic pointer, essentially
   // punting to the C programmer to point to some suitably initialized chunk
   // of memory), but at least we could have the code generator do something
   // reasonable for std::vector<plain old data types>.
   bool        isVector;
   bool        isDefaulted;
   std::string defaultValue;
};

// InfoChildren
struct InfoChildren {
   // A JSON spec can make a child node be:
   //    - an optional, and/or
   //    - a vector
   // but can't make it be a GNDStk::Defaulted. (The use of a default value for
   // child nodes just doesn't exist in the GNDS specifications, even though the
   // concept would seem to make sense.)
   std::string original; // without e.g. the "double" to "Double" change
   std::string name;
   std::string converter;// converter: callable w/operator() Node to/from type
   std::string filter;   // filter: bool callable(const Node &)
   std::string label;    // filter: allow for node lookup by "label" metadatum
   std::string ns;       // enclosing namespace
   std::string plain;    // underlying type, excluding namespace
   std::string type;     // underlying type
   std::string typeFull; // WITH any optional<> or vector<>
   std::string typeHalf; // withOUT any vector<>
   bool        isOptional;
   bool        isVector;
};

// InfoVariantsChildren
struct InfoVariantsChildren {
   std::string name;
   std::string ns;       // enclosing namespace
   std::string plain;    // underlying type, excluding namespace
   std::string type;     // underlying type
   bool        isVector;
};

// InfoVariants
struct InfoVariants {
   std::string name;
   std::string type;     // underlying type
   std::string typeFull; // WITH any optional<> or vector<>
   std::string typeHalf; // withOUT any vector<>
   bool        isVector;
   std::vector<InfoVariantsChildren> children;
};

// PerNamespace
struct PerNamespace {
   std::string cppPython; // cpp file for this namespace's Python interface
   std::string nsname;    // name of this namespace
};

// PerClass
struct PerClass {
   std::string cppPython; // cpp file for this class' Python interface
   std::string hppGNDStk; // hpp file for this class in GNDStk
   std::string headerC;   // header that works with both C and C++
   std::string sourceC;   // C++ backend source for the C interface

   std::string nsname;    // name of this class' namespace
   std::string clname;    // name of this class
   std::string nameGNDS;  // name of this class as a GNDS node

   std::string name() const { return nsname + "::" + clname; }

   // Actual printed code for the class. We build this up and then print
   // it later, after having determined a dependency-aware class ordering.
   std::string code;

   // Information about the contents of the class...
   // ...its metadata
   // ...its regular children
   // ...its variant children
   std::vector<InfoMetadata> metadata;
   std::vector<InfoChildren> children;
   std::vector<InfoVariants> variants;
   int nfields() const
      { return metadata.size() + children.size() + variants.size(); }

   // Data node?
   // If (and only if) isDataVector, elementType is considered. If it's "", then
   // this is the situation in GNDS in which the type of data residing in a node
   // is to be determined dynamically, via a string metadatum called valueType.
   // If elementType != "" (for example, elementType == "int" or "double"), then
   // elementType stipulates the wanted type.
   bool isDataString; // Example: <foo> This is a free-form text string </foo>
   bool isDataVector; // Example: <foo> 1.2 3.45 6.789 </foo>
   std::string elementType;
   // isDataNode: for convenience: either isDataString; or, isDataVector AND
   // per.elementType is NOT "" (so that we use DataNode instead of BlockData)
   bool isDataNode;
   bool cdata; // prefer "cdata" over plain data?

   // For shortcuts from objects of this class
   std::multimap<std::string,std::vector<std::string>> name2path;
};


// -----------------------------------------------------------------------------
// InfoSpecs
// -----------------------------------------------------------------------------

// Overarching data structure reflecting all of the autogenerator's input
// as well as various processed information
struct InfoSpecs {
   // From the JSON file on the command line
   std::string Path;
   std::string Project;
   std::string JSONDir;
   std::string Version;
   std::vector<std::string> JSONFiles;

   // Version, but with '_'s in place of '.'s
   std::string VersionUnderscore;

   // Directory-prefixed names
   std::string hppVersion; // hpp file for this version
   std::string hppKey;     // hpp file for this version's Meta and Child keys
   std::string hVersion;   // header file for both C and C++
   std::string cVersion;   // C++ backend source for the C interface

   // Changes to apply to a metadatum's name or a child node's name.
   // Example: "double" (GNDS v2.0, for example, actually has a "double" node)
   // to "Double" for C++.
   std::map<std::string,std::string> mapName;

   // Changes to apply to metadata/attribute type.
   // Examples: "Boolean" to "bool", "interpolation" to "enums::Interpolation".
   // We'll give a string ==> std::string type change as a freebie. :-)
   std::map<std::string,std::string> mapMetaType = {{"string","std::string"}};

   // Changes to apply to metadata/attribute default.
   std::map<std::string,std::string> mapMetaDefault;

   // For each class in the input JSON specifications, the namespace(s)
   // in which it appears.
   std::multimap<std::string,std::string> class2nspace;

   // Class dependencies: as originally determined, and after being sorted.
   // Elements of these vectors contain:
   //    theClass = {nsname,clname}
   //    dependencies = vector<{nsname,clname}>
   // These are (1) the class in question, and (2) its dependencies.
   std::vector<Class2Dependencies> ClassDependenciesRaw;
   std::vector<Class2Dependencies> ClassDependenciesSorted;

   // Map from namespace to information about the namespace
   std::map<std::string,PerNamespace> namespace2data;

   // Map from namespace::class to information about the class
   static inline const auto compare =
      [](const auto &a, const auto &b)
      {
         // In the event that we display entries in the map, we prefer putting
         // everything in alphabetical order based primarily on the class name,
         // with namespace only a secondary consideration. Someone looking for
         // a class need only consider its name, and not initially worry about
         // what namespace it's in.
         return
            a.clname <  b.clname || (
            a.clname == b.clname &&
            a.nsname <  b.nsname);
      };
   std::map<NamespaceAndClass,PerClass,decltype(compare)> class2data{compare};
}; // InfoSpecs


// -----------------------------------------------------------------------------
// Miscellaneous short functions
// -----------------------------------------------------------------------------

void action_helper(std::string str)
{
   str.resize(80,' ');
   // boldface + background color + foreground color + text
   // std::cout << "\033[1m\033[48;2;80;80;80m\033[38;2;255;255;255m" << str;
   // background color + foreground color + text
   std::cout << "\033[48;2;80;80;80m\033[38;2;255;255;255m" << str;
   std::cout << color::reset << std::endl;

   /*
   // loud colors; may or may not want
   static const int ncol = 80;
   static const int last = ncol-1;

   for (int col = 0; col < ncol; ++col) {
      int r = 255*(last-col)/last;
      int g = 255 - std::abs(255*(last-col-col)/last);
      int b = 255*col/last;
      std::cout << "\033[48;2;" << r << ";" << g << ";" << b << "m"
                << "\033[38;2;255;255;255m"
                << (col < str.size() ? str[col] : ' ');
   }
   std::cout << color::reset << std::endl;
   */
}

// Print text describing an action the code is about to take
template<class... ARGS>
void action(const ARGS &...args)
{
   static const std::string inverse = "\033[7m";
   static const std::string background(80,' ');
   std::cout << '\n';
   action_helper("");
   (action_helper(args), ...);
   action_helper("");
   std::cout << color::reset << std::endl;
}

// Is the string all whitespace?
bool allws(const std::string &str)
{
   for (const auto c : str)
      if (!isspace(c))
         return false;
   return true;
}

// Escape any double quotes in the string
std::string escape(const std::string &str)
{
   std::string ret;
   for (const auto c : str) {
      if (c == '"')
         ret += '\\';
      ret += c;
   }
   return ret;
}

// initializer
// Based on m.type and m.defaultValue, make something appropriate to use
// for initialization, as with: m.type var{return value of this function}
std::string initializer(const InfoMetadata &m)
{
   // Leave an empty or all-whitespace m.defaultValue as-is.
   // This is the "no initializer" case.
   if (allws(m.defaultValue))
      return "";

   // If of string type, add double quotes.
   // We assume that the input does NOT have the quotes already!
   // Note: we may not need all of these, but the GNDS manual does describe
   // several string-like types, so we might as well include them.
   if (m.type == "XMLName" || m.type == "UTF8Text" ||
       m.type == "printableText" || m.type == "quotedText" ||
       m.type == "tdText" || m.type == "string" || m.type == "std::string")
      return '"' + escape(m.defaultValue) + '"';

   // Leave as-is;
   // applicable for non-string (int, double, etc.) cases
   return m.defaultValue;
}

// Capitalize the first letter
std::string capital(const std::string &str)
{
   std::string ret = str;
   if (ret.size() > 0)
      ret[0] = toupper(ret[0]);
   return ret;
}

// Capitalize all letters
std::string allcaps(const std::string &str)
{
   std::string ret = str;
   for (size_t i = ret.size(); i--; )
      ret[i] = toupper(ret[i]);
   return ret;
}

// UpperCamel
std::string UpperCamel(const std::string &str)
{
   std::string ret;
   for (size_t i = 0; i < str.size(); ++i)
      if (str[i] != '_')
         ret += i ? str[i] : toupper(str[i]);
      else if (++i < str.size())
         ret += toupper(str[i]);
   return ret;
}


// Replace character
std::string replace(const std::string &str, const char from, const char to)
{
   std::string ret = str;
   for (size_t i = ret.size(); i--; )
      if (ret[i] == from)
         ret[i] = to;
   return ret;
}

// Stringify JSON
std::string stringify(const json::value &j)
{
   const std::string tmp = j.dump();
   return j.has<json::string>()
      ? tmp.substr(1, tmp.size()-2)
      : tmp;
}

// Does this JSON key look like a C++ style comment?
bool isComment(const std::string &key)
{
   return strncmp(key.data(), "//", 2) == 0;
}

// Does this JSON key/value pair appear to describe a class?
bool isClass(const json::pair &keyval)
{
   const auto &key = keyval.first;
   const auto &val = keyval.second;

   // a comment?
   if (isComment(key))
      return false;

   // not a class?
   if (key == "__namespace__" || key == "namespace" || key == "Specifications")
      return false;

   // not a node class?
   if ((val.contains("__class__") && val["__class__"].get<json::string>() != "nodes.Node") || (
        val.contains(  "class"  ) && val[  "class"  ].get<json::string>() != "nodes.Node")
   )
      return false;

   return true;
}

// getTimes
const std::string &getTimes(
   const PerClass &per, const std::string &key, const json::object &value
) {
   const std::string times = "times"; // shorter, less easily misspelled
   const std::string occurrence = "occurrence"; // accept; used in GNDS specs

   // need exactly one - not neither, not both
   if (value.contains(times) == value.contains(occurrence)) {
      log::error(
        "In namespace \"{}\", class \"{}\":\n"
        "Child node \"{}\" needs exactly one of \"times\" or \"occurrence\".\n"
        "Or, did you possibly intend \"{}\" to be an attribute/metadatum?",
         per.nsname, per.clname, key, key);
      throw std::exception{};
   }

   return value.contains(times)
      ? value[times].get<json::string>()
      : value[occurrence].get<json::string>();
}

// sep
std::string sep(int &count, const int total)
{
   return ++count < total ? "," : "";
}


// -----------------------------------------------------------------------------
// name* functions
// -----------------------------------------------------------------------------

// nameGNDS
// Name in a GNDS file (e.g., name of an XML element)
const std::string &nameGNDS(
   const json::pair &keyval,
   const std::string &nsname = "",
   const bool print = false
) {
   // For debugging
   if (debugging && print) {
      const std::string key = keyval.first;
      const std::string name = keyval.second.contains("name")
         ? keyval.second["name"].get<json::string>()
         : key;

      std::cout
         << "class:  "
         << std::setw(20) << std::left << nsname << " "
         << std::setw(48) << std::left << key << " "
         << (key == name ? " " : "*")  << " "
         << std::left << name << std::endl;
   }

   // As-is, directly as stipulated in the key in the JSON spec, except
   // that we allow a "name" entry in the key's value to override the key.
   return keyval.second.contains("name")
      ? keyval.second["name"].get<json::string>()
      : keyval.first;
}

// nameField
// Name of a field (metadatum or child node) in an autogenerated class
const std::string &nameField(const json::pair &keyval, const InfoSpecs &specs)
{
   const std::string &name = keyval.first;
   // Here, we apply any name-modification map that may have been provided
   // in a "changes" file. Such changes can fix, for example, the name "double"
   // that appears in some GNDS specs as a JSON key, given that "double" is
   // unsuitable for use as a variable name in C++.
   const auto it = specs.mapName.find(name);
   return it == specs.mapName.end() ? name : it->second;
}

// nameClass
// Name of an autogenerated class
std::string nameClass(const json::pair &keyval, const InfoSpecs &specs)
{
   // Capitalized version of either the JSON key, or, if applicable,
   // its change under the name-modification map in a "changes" file.
   const std::string &name = keyval.first;
   const auto it = specs.mapName.find(name);
   return capital(it == specs.mapName.end() ? name : it->second);
}

// namePython
// Name for Python
std::string namePython(const std::string &name)
{
   if (name.size() == 0)
      return name;
   std::string python;
   python += std::tolower(name[0]);
   for (auto it = name.begin()+1; it != name.end(); ++it) {
      if (std::isupper(*it) && std::islower(*(it-1)))
         python += '_';
      python += std::tolower(*it);
   }
   return python;
}


// -----------------------------------------------------------------------------
// Functions for getting certain information from JSON input
// -----------------------------------------------------------------------------

// Get the JSON's "namespace"
const std::string &getFileNamespace(const json::object &j)
{
   return j.contains("__namespace__")
      ? j["__namespace__"].get<json::string>()
      : j[  "namespace"  ].get<json::string>();
}

// Get the JSON's "type", with any relevant specs.mapMetaType entry applied
const std::string &getMetadatumType(const json::object &j, const InfoSpecs &specs)
{
   const std::string &type = j["type"].get<json::string>();
   const auto it = specs.mapMetaType.find(type);
   return it == specs.mapMetaType.end() ? type : it->second;
}

// Determine to what namespace childClass belongs. Context: we're (1) in a JSON
// spec with namespace parent.nsname, (2) in a parent node named parent.clname,
// and (3) wish to determine the proper namespace for the parent's child node
// named childClass. Parameter j is the JSON value ({...}) for this child node.
std::string getChildNamespace(
   const json::object &j, const InfoSpecs &specs,
   const PerClass &per, const std::string &childClass
) {
   // childClass' namespace...

   // ...is explicitly given by "__namespace__"or "namespace"
   if (j.contains("__namespace__")) return j["__namespace__"].get<json::string>();
   if (j.contains(  "namespace"  )) return j[  "namespace"  ].get<json::string>();

   // ...isn't given, and this child isn't in any of the JSONs :-(
   if (specs.class2nspace.count(childClass) == 0) {
      log::warning(
         "{}::{} has a child of unknown class {}",
         per.nsname, per.clname, childClass
      );
      return "unknownNamespace";
   }

   // ...isn't given, but we've seen the child in exactly *one* namespace
   if (specs.class2nspace.count(childClass) == 1)
      return specs.class2nspace.find(childClass)->second;

   // ...isn't given, and we've seen the child in *multiple* namespaces,
   // ...one of which is the parent's, which we'll assume is intended
   const auto range = specs.class2nspace.equal_range(childClass);
   for (auto it = range.first; it != range.second; ++it)
      if (it->second == per.nsname) {
         log::warning(
            "{}::{} has a child {} that appears in the present\n"
            "namespace but also in one or more other namespaces. We'll\n"
            "assume that the one in the present namespace is intended.\n"
            "If this is wrong, please provide a \"namespace\" entry.",
            per.nsname, per.clname, childClass
         );
         return per.nsname;
      }

   // ...isn't given, and we've seen the child in *multiple* namespaces,
   // ...none of which is the parent's; this is an ambiguous situation :-(
   std::stringstream warn;
   int count = 0;
   for (auto it = range.first; it != range.second; ++it)
      warn << (count++ == 0 ? "" : ", ") << it->second;
   log::warning(
      "{}::{} has a child of ambiguous class {}.\n"
      "Child class {} appears in all of the following namespaces:\n{}",
      per.nsname, per.clname, childClass, childClass, warn.str()
   );

   return "ambiguousNamespace";
}


// -----------------------------------------------------------------------------
// getClass* functions re: metadata, children, variant children
// -----------------------------------------------------------------------------

// getClassMetadata
void getClassMetadata(
   const json::object &j, const InfoSpecs &specs,
   PerClass &per
) {
   for (const auto &field : j.items()) {
      if (beginsin(field.first, "//"))
         continue;
      if (!field.second.has<json::object>())
         continue;
      const json::object &metaRHS = field.second.get<json::object>();

      // Name
      InfoMetadata m;
      m.original = nameGNDS(field);
      m.name = nameField(field,specs);

      // Converter, if given
      m.converter = metaRHS.contains("converter") ? metaRHS["converter"].get<json::string>() : "";

      // Type
      m.type = getMetadatumType(metaRHS,specs);

      // Has default?
      m.defaultValue = "";
      if (metaRHS.contains("default") && !metaRHS["default"].is_null()) {
         m.defaultValue = stringify(metaRHS["default"]);
         // Apply the "changes.json" change, if any, to the given value
         const auto it = specs.mapMetaDefault.find(m.defaultValue);
         if (it != specs.mapMetaDefault.end())
            m.defaultValue = it->second;
      };
      if (m.defaultValue != "") {
         // If it has a default, then presumably it isn't required...
         if (metaRHS["required"].get<json::boolean>()) {
            log::error(
              "In namespace \"{}\", class \"{}\",\n"
              "metadatum \"{}\" has a default ({}), but is required.\n"
              "If it really is required, then it shouldn't have a default.\n"
              "If it really has a default, then presumably it isn't required.",
               per.nsname, per.clname, m.name, m.defaultValue);
            throw std::exception{};
         }
      }

      // Optional? (not required, and has no default)
      m.isOptional = !metaRHS["required"].get<json::boolean>() && m.defaultValue == "";
      const std::string optPrefix = m.isOptional ? "std::optional<" : "";
      const std::string optSuffix = m.isOptional ? ">" : "";

      // Defaulted? (not required, but does have a default)
      m.isDefaulted = !metaRHS["required"].get<json::boolean>() && m.defaultValue != "";
      const std::string defPrefix = m.isDefaulted ? "Defaulted<" : "";
      const std::string defSuffix = m.isDefaulted ? ">" : "";

      // Full type, including any optional<> or Defaulted<>
      m.typeFull =
         optPrefix + defPrefix +
         m.type +
         defSuffix + optSuffix;

      // Add to per.metadata
      per.metadata.push_back(m);
   }
} // getClassMetadata


// getClassChildren
void getClassChildren(
   const json::object &j, const InfoSpecs &specs,
   PerClass &per, Class2Dependencies &dep
) {
   for (const auto &field : j.items()) {
      if (beginsin(field.first, "//"))
         continue;
      if (!field.second.has<json::object>())
         continue;
      const json::object &elemRHS = field.second.get<json::object>();

      // Choice children are handled elsewhere
      const std::string &times = getTimes(per, field.first, elemRHS);
      if (times == "choice" || times == "choice+" || times == "choice2+")
         continue;

      // Name
      InfoChildren c;
      c.original = nameGNDS(field);
      c.name = nameField(field,specs);

      // Converter, Filter, and Label, if given
      c.converter = elemRHS.contains("converter") ? elemRHS["converter"].get<json::string>() : "";
      c.filter = elemRHS.contains("filter") ? elemRHS["filter"].get<json::string>() : "";
      c.label = elemRHS.contains("label") ? elemRHS["label"].get<json::string>() : "";

      // Type, excluding namespace
      c.plain = nameClass(field,specs);

      // Type, including namespace
      c.ns = getChildNamespace(elemRHS, specs, per, c.plain);
      c.type = c.ns + "::" + c.plain;

      // Optional?
      c.isOptional = !elemRHS["required"].get<json::boolean>();
      const std::string optPrefix = c.isOptional ? "std::optional<" : "";
      const std::string optSuffix = c.isOptional ? ">" : "";

      // Vector?
      c.isVector = times == "0+" || times == "1+" || times == "2+";
      const std::string vecPrefix = c.isVector ? "std::vector<" : "";
      const std::string vecSuffix = c.isVector ? ">" : "";

      // Full type, including any optional<> or vector<>
      // If both, use optional<vector>; the reverse makes less sense
      c.typeFull =
         optPrefix + vecPrefix +
         c.type +
         vecSuffix + optSuffix;

      // Partial type, not including any vector. This is used in the context
      // of this child node's entry in the multi-query key, where vector will
      // be implicit if it's a "many" (not a "one") child.
      c.typeHalf =
         optPrefix +
         c.type +
         optSuffix;

      // Save as a dependency (if it's not its own dependency)
      if (c.type != per.name())
         dep.dependencies.push_back(
            NamespaceAndClass(c.ns,nameClass(field,specs)));

      // Add to per.children
      per.children.push_back(c);
   }
} // getClassChildren


// getClassVariants
void getClassVariants(
   const json::object &j, const InfoSpecs &specs,
   PerClass &per, Class2Dependencies &dep
) {
   // Initialize per.variants, a vector<InfoVariants> that has the "choice"
   // children from the current class. Computing a map<string,InfoVariants>,
   // first, turns out to be convenient, given the manner in which the choice
   // children appear in the JSON specifications: listed in a "flat" manner,
   // as child nodes, rather than grouped one level deeper inside of, say,
   // a "choice" JSON key. Remark: this code supports the option of having
   // multiple sets of choices under the current parent; for example, the
   // parent can have {X or Y}, and (independently) have {A or B or C}. Our
   // JSON "variant" key facilitates this: give the same value for X and Y,
   // and the same value for A, B, and C. At the time of this writing, GNDS
   // specifications appear to allow for only one choice-between-things (just
   // X,Y, for example, or just A,B,C) in a given parent, but we believe that
   // our extension may prove to be useful at some point.

   std::map<std::string,InfoVariants> map;

   // Pass 1
   // Collect "variant" names, and if ever it's absent, a to-be-determined
   // name for all choice children for which it's absent
   for (const auto &field : j.items()) {
      if (beginsin(field.first, "//"))
         continue;

      // Is it a choice child?
      if (!field.second.has<json::object>())
         continue;
      const json::object &elemRHS = field.second.get<json::object>();
      const std::string &times = getTimes(per,field.first,elemRHS);
      if (times != "choice" && times != "choice+" && times != "choice2+")
         continue;

      // Variant name
      const std::string variantName = elemRHS.contains("variant")
         ? elemRHS["variant"].get<json::string>()
         : ""; // to be determined
      map.insert(std::make_pair(variantName,InfoVariants{}));
   }

   // Pass 2
   for (const auto &field : j.items()) {
      if (beginsin(field.first, "//"))
         continue;

      // Is it a choice child?
      if (!field.second.has<json::object>())
         continue;
      const json::object &elemRHS = field.second.get<json::object>();
      const std::string &times = getTimes(per,field.first,elemRHS);
      if (times != "choice" && times != "choice+" && times != "choice2+")
         continue;

      // Variant name
      const std::string variantName = elemRHS.contains("variant")
         ? elemRHS["variant"].get<json::string>()
         : "";
      auto it = map.find(variantName);
      assert(it != map.end()); // should be there from the earlier loop

      // For the individual child that's part of a choice...
      InfoVariantsChildren c;
      // ...its name
      c.name = nameField(field,specs);
      // ...its type, excluding namespace
      c.plain = nameClass(field,specs);
      // ...its type, including namespace
      c.ns = getChildNamespace(elemRHS, specs, per, c.plain);
      c.type = c.ns + "::" + c.plain;
      // ...its vector-ness
      c.isVector = times == "choice+" || times == "choice2+";

      // The GNDS JSON specifications all have "required":false for individual
      // choices in a set of choices; the concept of "the entire choice can be
      // either required or optional" doesn't seem to exist. We could support
      // it, but for now, we'll just ensure that "required":false is followed.

      assert(!elemRHS["required"].get<json::boolean>());

      InfoVariants &v = it->second;
      v.isVector = c.isVector;
      v.children.push_back(c);

      // Save as a dependency (if it's not its own dependency)
      if (c.type != per.name())
         dep.dependencies.push_back(
            NamespaceAndClass(c.ns,nameClass(field,specs)));
   }

   // Pass 3
   for (auto &pair : map) {
      InfoVariants &v = pair.second;
      assert(v.children.size() > 0);

      const std::string vecPrefix = v.isVector ? "std::vector<" : "";
      const std::string vecSuffix = v.isVector ? ">" : "";

      v.name = pair.first;
      v.type = pair.first + "_t";

      for (const auto &c : v.children) {
         assert(c.isVector == v.isVector);
         if (pair.first == "")
            v.name += (v.name == "" ? "_" : "") + c.name;
      }
      v.typeHalf = v.type;
      v.typeFull = vecPrefix + v.type + vecSuffix;

      per.variants.push_back(v);
   }
} // getClassVariants


// -----------------------------------------------------------------------------
// writer
// -----------------------------------------------------------------------------

// Comment-related markup
const auto largeComment = "// " + std::string(77,'-');
const auto smallComment = "// " + std::string(24,'-');

class writer {
   std::ostream &s;
   std::ofstream fstream;
   std::ostringstream sstream;

   static inline const char substitute = '@';
   static inline const int indent = 3;
   static inline const std::string message =
      "\n"
      "// THIS FILE WAS AUTOGENERATED!\n"
      "// DO NOT MODIFY!\n";

   // recurse is used to prevent multiple reports of equivalent errors
   // as we step through the format string and arguments while printing.
   static int recurse;

   template<class T, class... Ts>
   void checkArgs(const std::string &str, const T &value, Ts &&...args)
   {
      if (recurse == 0) {
         using last = decltype(
            std::get<sizeof...(args)>(std::make_tuple(value,args...)));
         const size_t nsub = std::count(str.begin(),str.end(),substitute);
         // a bool last argument is not interpreted as an argument to print...
         const size_t narg =
            1 + sizeof...(args) - std::is_same_v<std::decay_t<last>,bool>;
         if (narg != nsub) {
            log::error(
               "Number of '{}' substitution characters and arguments "
               "don't match:\n"
               "writer(\"{}\", ...)", substitute, str);
            throw std::exception{};
         }
      }
   }

public:

   // writer()
   // Use a string stream
   explicit writer(const bool autogen = true) :
      s(sstream)
   {
      if (autogen) s << message;
   }

   // writer(file)
   // Use a file stream
   explicit writer(const std::string &file, const bool autogen = true) :
      s(fstream), fstream(file)
   {
      if (autogen) s << message;
   }

   // str()
   std::string str() const
   {
      if (&s != &sstream) {
         log::error(
            "writer.str() is available only for a writer "
            "that was default constructed"
         );
         throw std::exception{};
      }
      return sstream.str();
   }

   // ------------------------
   // operator()
   // ------------------------

   // char* cases are needed in addition to std::string, for disambiguation.
   // level is the indentation level.

   // operator()(string, newline)
   template<class T = bool, class = std::enable_if_t<std::is_same_v<T,bool>>>
   void operator()(const std::string &str = "", const T newline = true)
   {
      s << str;
      if (newline)
         s << std::endl;
   }

   template<class T, class = std::enable_if_t<std::is_same_v<T,bool>>>
   void operator()(
      const char *const str, const T newline = true
   ) {
      operator()(std::string(str), newline);
   }

   // operator()(level, string, newline)
   void operator()(
      const int level, const std::string &str = "", const bool newline = true
   ) {
      operator()(std::string(level*indent,' ') + str, newline);
   }

   void operator()(
      const int level, const char *const str, const bool newline = true
   ) {
      operator()(level, std::string(str), newline);
   }

   // operator()(string, value, args)
   template<
      class T, class... Ts,
      class = std::enable_if_t<!std::is_same_v<T,bool>>
   >
   void operator()(const std::string &str, const T &value, Ts &&...args)
   {
      checkArgs(str, value, std::forward<Ts>(args)...);
      recurse++;
      for (const auto &ch : str)
         if (ch != substitute)
            s << ch;
         else {
            s << value;
            operator()(std::string(&ch+1), std::forward<Ts>(args)...);
            break;
         }
      recurse--;
   }

   // operator()(level, string, value, args)
   template<
      class T, class... Ts,
      class = std::enable_if_t<!std::is_same_v<T,bool>>
   >
   void operator()(
      const int level, const std::string &str, const T &value, Ts &&...args
   ) {
      checkArgs(str, value, std::forward<Ts>(args)...);
      recurse++;
      operator()(
         std::string(level*indent,' ') + str,
         value,
         std::forward<Ts>(args)...
      );
      recurse--;
   }
};

int writer::recurse = 0;

// helper
template<class... Ts>
void section(writer &out, const std::string &str, Ts &&...args)
{
   out();
   out();
   out(largeComment);
   out(str, std::forward<Ts>(args)...);
   out(largeComment);
}


// -----------------------------------------------------------------------------
// writeClassPrefix
// -----------------------------------------------------------------------------

void writeClassPrefix(writer &out, const PerClass &per)
{
   // namespace
   out("namespace @ {", per.nsname);

   // comment introducing class
   out();
   out(largeComment);
   out("// @::", per.nsname);
   out("// class @", per.clname);
   out(largeComment);

   // class begin
   // A namespace prefix in Component<> prevents possible ambiguities with the
   // Child<> object, for the class, brought in through key.hpp. Normally the
   // class name is capitalized while the Child<> object isn't, but if the node
   // name was already capitalized in the specs (an example we encountered was
   // the name "XYs1d"), then the Child<> key would reflect that. Then, without
   // the nsname:: below, we'd have an ambiguity.
   out();
   out("class @ :", per.clname);

   if (per.isDataVector && per.elementType == "") {
      out(1,"public Component<@::@,true>", per.nsname, per.clname);
   } else if (per.isDataVector) {
      out(1,"public Component<@::@>,", per.nsname, per.clname);
      out(1,"public DataNode<std::vector<@>,@>", per.elementType,
          per.cdata ? "true" : "false");
   } else if (per.isDataString) {
      out(1,"public Component<@::@>,", per.nsname, per.clname);
      out(1,"public DataNode<std::string,@>",
          std::string(per.cdata ? "true" : "false"));
   } else {
      out(1,"public Component<@::@>", per.nsname, per.clname);
   }

   out("{");
   out(1,"friend class Component;");
} // writeClassPrefix


// -----------------------------------------------------------------------------
// nameMap
// -----------------------------------------------------------------------------

const std::map<std::string,std::pair<std::string,std::string>> nameMap =
{
   // ----------------------   -----------            -----------------
   // In per.elementType       The                    A name to use
   // or in per.metadata's     appropriate            for the function
   // valueType defaultValue   C++ type               that returns them
   // ----------------------   -----------            -----------------

   // Described in the GNDS manual.
   // I'm not sure which of the several types that map to std::string can,
   // or would, appear in any GNDS specifications in such a way that we'd
   // need it here, but listing all "string-like" types shouldn't hurt.
   { "Integer32"          , { "int"                , "ints"        } },
   { "UInteger32"         , { "unsigned"           , "uints"       } },
   { "Float64"            , { "double"             , "doubles"     } },
   { "XMLName"            , { "std::string"        , "strings"     } },
   { "UTF8Text"           , { "std::string"        , "strings"     } },
   { "printableText"      , { "std::string"        , "strings"     } },
   { "quotedText"         , { "std::string"        , "strings"     } },
   { "tdText"             , { "std::string"        , "strings"     } },

   // We allow these as well.
   { "int"                , { "int"                , "ints"        } },
   { "unsigned"           , { "unsigned"           , "uints"       } },
   { "double"             , { "double"             , "doubles"     } },
   { "string"             , { "std::string"        , "strings"     } },
   { "std::string"        , { "std::string"        , "strings"     } },

   // Allow other sensible things.
   { "char"               , { "char"               , "chars"       } },
   { "signed char"        , { "signed char"        , "schars"      } },
   { "short"              , { "short"              , "shorts"      } },
   { "long"               , { "long"               , "longs"       } },
   { "long long"          , { "long long"          , "longlongs"   } },
   { "unsigned char"      , { "unsigned char"      , "uchars"      } },
   { "unsigned short"     , { "unsigned short"     , "ushorts"     } },
   { "unsigned int"       , { "unsigned"           , "uints"       } },
   { "unsigned long"      , { "unsigned long"      , "ulongs"      } },
   { "unsigned long long" , { "unsigned long long" , "ulonglongs"  } },
   { "float"              , { "float"              , "floats"      } },
   { "long double"        , { "long double"        , "longdoubles" } },
   { "quad"               , { "long double"        , "quads"       } }
};


// -----------------------------------------------------------------------------
// writeClassForComponent
// -----------------------------------------------------------------------------

void writeClassForComponent(writer &out, const PerClass &per)
{
   // using [name for variant] = ...
   if (per.variants.size())
      out();
   for (const auto &v : per.variants) {
      out(1,"using @ = std::variant<", v.type);
      int count = 0;
      const int total = v.children.size();
      for (const auto &c : v.children)
         out(2,"@@", c.type, sep(count,total));
      out(1,">;");
   }

   // ------------------------
   // Simple functions
   // ------------------------

   out();
   out(1,smallComment);
   out(1,"// For Component");
   out(1,smallComment);
   out();
   out(1,"// Names: this namespace and class, "
       "and original nodes (as in XML <...>)");
   out(1,"static auto NAMESPACE() { return \"@\"; }", per.nsname);
   out(1,"static auto CLASS() { return \"@\"; }", per.clname);
   out(1,"static auto NODENAME() { return \"@\"; }", per.nameGNDS);

   // ------------------------
   // KEYS()
   // ------------------------

   // KEYS() begin
   out();
   out(1,"// Core Interface multi-query to transfer information to/from core Nodes");
   out(1,"static auto KEYS()");
   out(1,"{");

   // KEYS() contents
   int count = 0;
   const int total = per.nfields() + int(per.isDataNode);
   out(2,"return");

   // comment
   out(3,"// comment");
   out(3,"++Child<std::string>(special::comment) / CommentConverter{}@",
       std::string(total ? " |" : ""));

   // metadata
   if (per.metadata.size()) {
      out();
      out(3,"// metadata");
   }
   for (const auto &m : per.metadata) {
      out(3,"@{@}", m.typeFull, initializer(m));
      out(4,"/ Meta<>(\"@\")@@",
          m.original,
          // direct-specified converter, if any
          m.converter == "" ? "" : (" / " + m.converter),
          // separator between next entry
          ++count < total ? " |" : ""
      );
   }

   // children
   if (per.children.size() || per.variants.size()) {
      out();
      out(3,"// children");
   }
   for (const auto &c : per.children) {
      out(3,"@Child<@>",
          c.isVector ? "++" : "--",
          c.typeHalf // without any std::vector
      );
      out(4,"(\"@\")@@@@",
          c.original,
          // direct-specified converter, if any
          c.converter == "" ? "" : (" / " + c.converter),
          // direct-specified filter, if any
          c.filter == "" ? "" : (" + " + c.filter),
          // simple filter: value required for metadatum label, if any;
          // this augments (it doesn't replace) any direct-given filter
          c.label == "" ? "" : (" | \"" + c.label + '"'),
          // separator between next entry
          ++count < total ? " |" : ""
      );
   }

   // variants
   for (const auto &v : per.variants) {
      out(3,"@{}", v.typeHalf); // without any std::vector
      out(4,"/ @(", v.isVector ? "++" : "--", false);
      int n = 0; // for alternatives; not to be confused w/count
      for (const auto &c : v.children)
         out("@Child<>(\"@\")", n++ == 0 ? "" : " || ", c.name, false);
      out(")@",
          ++count < total ? " |" : ""
         );
   }

   // data
   if (per.isDataNode) {
      out();
      out(3,"// data");
      out(3,"--Child<DataNode>(special::self) / DataConverter{}");
   }

   // KEYS() end
   out(2,";");
   out(1,"}");

   // ------------------------
   // FIELDNAMES()
   // ------------------------

   out();
   out(1,"// Data member names. "
       "Usually - but not necessarily - the same as the node");
   out(1,"// names appearing in KEYS(). "
       "These are used by Component's prettyprinter.");
   out(1,"static const auto &FIELDNAMES()");
   out(1,"{");
   out(2,"static const std::vector<std::string> names = {");

   count = 0;
   out(3,"\"comment\"@", std::string(total ? "," : ""));
   for (const auto &m : per.metadata)
      out(3,"\"@\"@", m.name, ++count < total ? "," : "");
   for (const auto &c : per.children)
      out(3,"\"@\"@", c.name, ++count < total ? "," : "");
   for (const auto &v : per.variants)
      out(3,"\"@\"@", v.name, ++count < total ? "," : "");

   // Here, and in the Python case below, I'm not - for now - dealing with
   // the case of a dynamic data type, as with the "valueType" flag discussed
   // in the original GNDS specs. We may or may not really need support for
   // that If we do, we'll perhaps end up with several names: at least ints,
   // doubles, and strings. The way we use *references* in the C++ classes
   // (referring from inside the class to the base DataNode<vector> in the
   // vector case), isn't compatible, as-is, with the dynamic data type case.
   // There, I suppose we'd need a reference to the variant that can contain
   // vector<various types>. (For python bindings we call functions, rather
   // than having references of some sort.)
   if (per.isDataNode) {
      if (per.isDataString)
         out(3,"\"string\"");
      else {
         auto it = nameMap.find(per.elementType);
         if (it != nameMap.end())
            out(3,"\"@\"", it->second.second);
         else
            out(3,"\"\""); // really shouldn't happen
      }
   }

   out(2,"};");
   out(2,"return names;");
   out(1,"}");

   // ------------------------
   // PYTHONNAMES()
   // ------------------------

   out();
   out(1,"// Data member names, as they'll be presented "
       "in the Python bindings.");
   out(1,"static const auto &PYTHONNAMES()");
   out(1,"{");
   out(2,"static const std::vector<std::string> names = {");

   count = 0;
   out(3,"\"comment\"@", std::string(total ? "," : ""));
   for (const auto &m : per.metadata)
      out(3,"\"@\"@", namePython(m.name), ++count < total ? "," : "");
   for (const auto &c : per.children)
      out(3,"\"@\"@", namePython(c.name), ++count < total ? "," : "");
   for (const auto &v : per.variants)
      out(3,"\"@\"@", namePython(v.name), ++count < total ? "," : "");

   if (per.isDataNode) {
      if (per.isDataString)
         out(3,"\"string\"");
      else {
         auto it = nameMap.find(per.elementType);
         if (it != nameMap.end())
            out(3,"\"@\"", it->second.second);
         else
            out(3,"\"\""); // really shouldn't happen
      }
   }

   out(2,"};");
   out(2,"return names;");
   out(1,"}");
} // writeClassForComponent


// -----------------------------------------------------------------------------
// writeClassSuffix
// -----------------------------------------------------------------------------

void writeClassSuffix(
   writer &out, const PerClass &per, const InfoSpecs &specs
) {
   // ------------------------
   // assignment
   // ------------------------

   out();
   out(1,smallComment);
   out(1,"// Assignment operators");
   out(1,smallComment);
   out();

   // copy
   out(1,"// copy");
   out(1,"@ &operator=(const @ &other)", per.clname, per.clname);
   out(1,"{");
   out(2,"if (this != &other) {");
   if (printCtorCalls)
      out(3,"std::cout << \"assign: @: copy\" << std::endl;", per.clname);
   out(3,"Component::operator=(other);");
   if (per.isDataNode)
      out(3,"DataNode::operator=(other);");
   out(3,"comment = other.comment;");
   if (per.nfields() > 0) {
      for (const auto &m : per.metadata)
         out(3,"@ = other.@;", m.name, m.name);
      for (const auto &c : per.children)
         out(3,"@ = other.@;", c.name, c.name);
      for (const auto &v : per.variants)
         out(3,"@ = other.@;", v.name, v.name);
   }
   out(2,"}");
   out(2,"return *this;");
   out(1,"}");
   out();

   // move
   out(1,"// move");
   out(1,"@ &operator=(@ &&other)", per.clname, per.clname);
   out(1,"{");
   out(2,"if (this != &other) {");
   if (printCtorCalls)
      out(3,"std::cout << \"assign: @: move\" << std::endl;", per.clname);
   out(3,"Component::operator=(std::move(other));");
   if (per.isDataNode)
      out(3,"DataNode::operator=(std::move(other));");
   out(3,"comment = std::move(other.comment);");
   if (per.nfields() > 0) {
      for (const auto &m : per.metadata)
         out(3,"@ = std::move(other.@);", m.name, m.name);
      for (const auto &c : per.children)
         out(3,"@ = std::move(other.@);", c.name, c.name);
      for (const auto &v : per.variants)
         out(3,"@ = std::move(other.@);", v.name, v.name);
   }
   out(2,"}");
   out(2,"return *this;");
   out(1,"}");

   // ------------------------
   // customization #include
   // ------------------------

   out();
   out(1,smallComment);
   out(1,"// Custom functionality");
   out(1,smallComment);
   out();
   out(1,"#include \"@/@/@/@/src/custom.hpp\"",
       specs.Project, specs.Version, per.nsname, per.clname);

   // this *follows* the customization #include (because it might be used there)
   out(1,"#undef NJOY_GNDSTK_COMPONENT");

   // ------------------------
   // class+namespace end
   // ------------------------

   out("}; // class @", per.clname);
   out();
   out("} // namespace @", per.nsname);
} // writeClassSuffix


// -----------------------------------------------------------------------------
// writeClass*
// For metadata, children, and variant children
// -----------------------------------------------------------------------------

// writeClassContentMetadata
void writeClassContentMetadata(
   writer &out, const PerClass &per,
   std::string &title
) {
   if (per.metadata.size()) {
      out();
      out(1,"// metadata");
   }

   for (const auto &m : per.metadata) {
      if (m.type == "bool" && m.isOptional) {
         std::cout
            << title
            << color::custom::red
            << "   Metadatum will be an optional bool (not recommended): "
            << color::custom::blue << m.name
            << color::reset << std::endl;
         title = "";
      }

      if (per.isDataVector && per.elementType == "" &&
         (m.name == "length" || m.name == "start" || m.name == "valueType")
      ) {
         out(1,"mutable Field<@>", m.typeFull);
         out(2,"@{this", m.name, false);
      } else {
         out(1,"Field<@>", m.typeFull);
         out(2,"@{this", m.name, false);
      }
      if (m.defaultValue != "")
         out(",defaults.@", m.name, false);
      out("};");
   }
}

// writeClassContentChildren
void writeClassContentChildren(writer &out, const PerClass &per)
{
   if (per.children.size()) {
      out();
      out(1,"// children");
   }

   for (const auto &c : per.children) {
      out(1,"Field<@>", c.typeFull);
      out(2,"@{this};", c.name);

      if (debugging && c.name == "xs") {
         // todo
         // Consider some terminology changes...
         //    ns ==> nsname
         //    plain ==> key (as in, the JSON key)
         //    typeFull ==> ?
         //    typeHalf ==> ?
         // Also ordering:
         //    nsname
         //    key
         //    name
         //    type
         //    typeFull
         //    typeHalf
         std::cout << "name     == " << c.name     << std::endl;
         std::cout << "ns       == " << c.ns       << std::endl;
         std::cout << "plain    == " << c.plain    << std::endl;
         std::cout << "type     == " << c.type     << std::endl;
         std::cout << "typeFull == " << c.typeFull << std::endl;
         std::cout << "typeHalf == " << c.typeHalf << std::endl;
      }
   }
}

// writeClassContentVariants
void writeClassContentVariants(writer &out, const PerClass &per)
{
   if (per.variants.size()) {
      out();
      out(1,"// children - variant");
   }

   for (const auto &v : per.variants) {
      out(1,"Field<@>", v.typeFull);
      out(2,"@{this};", v.name);

      for (const auto &c : v.children) {
         out(1,"FieldPart<decltype(@),@> @{@};",
             v.name, c.type, c.name, v.name);
      }
   }
}


// -----------------------------------------------------------------------------
// writeClassCtor*
// -----------------------------------------------------------------------------

// writeClassCtorComponent
void writeClassCtorComponent(
   writer &out, const PerClass &per, const bool copyOrMove,
   const bool newline = true
) {
   out(2,"NJOY_GNDSTK_COMPONENT(@)",
       std::string(copyOrMove ? "other.baseBlockData()" : "BlockData{}"),
       newline);
}


// writeClassCtorBody
void writeClassCtorBody(
   writer &out,
   const std::string &kind,
   const std::string &clname,
   const std::string &argName
) {
   out(1,"{");
   if (printCtorCalls)
      out(2,"std::cout << \"ctor: @: @\" << std::endl;", clname, kind);
   out(2,"Component::finish(@);", argName);
   out(1,"}");
}


// writeClassCtors
void writeClassCtors(writer &out, const PerClass &per)
{
   // ------------------------
   // macro
   // ------------------------

   int count; const int total = per.nfields();

   out();
   out(1,"#define NJOY_GNDSTK_COMPONENT(blockdata) \\");
   out(1,"Component( \\");
   out(2,"blockdata, \\");
   out(2,"this->comment@ \\", std::string(total || per.isDataNode ? "," : ""));
   count = 0;
   for (const auto &m : per.metadata)
      out(2,"this->@@ \\", m.name,
          ++count < total || per.isDataNode ? "," : "");
   for (const auto &c : per.children)
      out(2,"this->@@ \\", c.name,
          ++count < total || per.isDataNode ? "," : "");
   for (const auto &v : per.variants)
      out(2,"this->@@ \\", v.name,
          ++count < total || per.isDataNode ? "," : "");
   if (per.isDataNode)
      out(2,"static_cast<DataNode &>(*this) \\");
   out(1,")");

   // ------------------------
   // ctor: default
   // ------------------------

   out();
   out(1,"// default");
   out(1,"@() :", per.clname);
   writeClassCtorComponent(out, per, false);
   writeClassCtorBody(out, "default", per.clname, "");

   // ------------------------
   // ctor: from fields
   // ------------------------

   if (total > 0) {
      out();

      // comment for this constructor
      out(1,"// from fields, comment excluded");

      // informational message, if applicable
      for (const auto &m : per.metadata)
         if (m.isDefaulted) {
            out(1,"// optional replaces Defaulted; "
                "this class knows the default(s)");
            break;
         }

      // signature
      count = 0;
      out(1,"explicit @(", per.clname);

      for (const auto &m : per.metadata) {
         out(2,"const wrapper<@>",
             m.isDefaulted ? "std::optional<" + m.type + ">" : m.typeFull);
         out(3,"&@@@",
             m.name, count ? " = {}" : "", count+1 < total ? "," : "");
         count++;
      }
      for (const auto &c : per.children) {
         out(2,"const wrapper<@>",
             c.typeFull);
         out(3,"&@@@",
             c.name, count ? " = {}" : "", count+1 < total ? "," : "");
         count++;
      }
      for (const auto &v : per.variants) {
         out(2,"const wrapper<@>",
             v.typeFull);
         out(3,"&@@@",
             v.name, count ? " = {}" : "", count+1 < total ? "," : "");
         count++;
      }

      // base constructor call
      out(1,") :");
      writeClassCtorComponent(out, per, false, false);

      // initialize fields
      out(",");
      count = 0;
      for (const auto &m : per.metadata)
         if (m.isDefaulted)
            out(2,"@(this,defaults.@,@)@",
                m.name, m.name, m.name, sep(count,total));
         else
            out(2,"@(this,@)@", m.name, m.name, sep(count,total));
      for (const auto &c : per.children)
         out(2,"@(this,@)@", c.name, c.name, sep(count,total));
      for (const auto &v : per.variants)
         out(2,"@(this,@)@", v.name, v.name, sep(count,total));

      // body
      writeClassCtorBody(out, "fields", per.clname, "");
   }

   // ------------------------
   // ctor: node
   // ------------------------

   out();
   out(1,"// from node");
   out(1,"explicit @(const Node &node) :", per.clname);
   writeClassCtorComponent(out, per, false);
   writeClassCtorBody(out, "node", per.clname, "node");

   // ------------------------
   // ctor: vector
   // ------------------------

   if (per.isDataVector && per.elementType == "") {
      out();
      out(1,"// from vector");
      out(1,"template<class T, class = "
          "std::enable_if_t<BLOCKDATA::template supported<T>>>");
      out(1,"explicit @(const std::vector<T> &vector) :",
          per.clname);
      writeClassCtorComponent(out, per, false);
      writeClassCtorBody(out, "vector", per.clname, "vector");
   } else if (per.isDataVector) {
      out();
      out(1,"// from vector<@>", per.elementType);
      out(1,"explicit @(const std::vector<@> &vector) :",
          per.clname, per.elementType);
      writeClassCtorComponent(out, per, false,false);
      out(",");
      out(2,"DataNode(vector)");
      writeClassCtorBody(out, "vector", per.clname, "vector");
   } else if (per.isDataString) {
      // todo
      // Perhaps construction from std::string here, as we do with std::vector
      // above, but we need to be careful. What if the class has a std::string
      // metadatum and no other fields? Then, I think, the constructor created
      // here would conflict with the "from fields" constructor. And, actually,
      // perhaps this sort of thing can happen in relation to std::vector too.
      // With other priorities being more pressing, let's address these concerns
      // only if and when necessary.
   }

   // ------------------------
   // ctor: copy
   // ------------------------

   out();
   out(1,"// copy");
   out(1,"@(const @ &other) :", per.clname, per.clname);
   writeClassCtorComponent(out, per, true, false);
   out(",");
   if (per.isDataNode)
      out(2,"DataNode(other),");
   out(2,"comment(this,other.comment)@", std::string(total ? "," : ""));
   count = 0;
   for (const auto &m : per.metadata)
      out(2,"@(this,other.@)@", m.name, m.name, sep(count,total));
   for (const auto &c : per.children)
      out(2,"@(this,other.@)@", c.name, c.name, sep(count,total));
   for (const auto &v : per.variants)
      out(2,"@(this,other.@)@", v.name, v.name, sep(count,total));
   writeClassCtorBody(out, "copy", per.clname, "other");

   // ------------------------
   // ctor: move
   // ------------------------

   out();
   out(1,"// move");
   out(1,"@(@ &&other) :", per.clname, per.clname);
   writeClassCtorComponent(out, per, true, false);
   out(",");
   if (per.isDataNode)
      out(2,"DataNode(std::move(other)),");
   out(2,"comment(this,std::move(other.comment))@",
       std::string(total ? "," : ""));
   count = 0;
   for (const auto &m : per.metadata)
      out(2,"@(this,std::move(other.@))@", m.name, m.name, sep(count,total));
   for (const auto &c : per.children)
      out(2,"@(this,std::move(other.@))@", c.name, c.name, sep(count,total));
   for (const auto &v : per.variants)
      out(2,"@(this,std::move(other.@))@", v.name, v.name, sep(count,total));
   writeClassCtorBody(out, "move", per.clname, "other");
} // writeClassCtors


// -----------------------------------------------------------------------------
// writeClass
// -----------------------------------------------------------------------------

void writeClass(
   const InfoSpecs &specs, std::string &title,
   const PerClass &per, std::string &code)
{
   // false: no "file was autogenerated" message, because in writeClass we're
   // writing certain class contents to a string, not writing an entire file.
   writer out(false);

   // output: class begin
   writeClassPrefix(out, per);

   // output: for the Component base
   writeClassForComponent(out, per);

   // section: public interface
   out();
   out(1,smallComment);
   out(1,"// Public interface");
   out(1,smallComment);
   out();
   out("public:");

   // output: using directives
   out();
   out(1,"using component_t = Component;");
   out(1,"using Component::construct;");
   if (per.isDataVector && per.elementType == "")
      out(1,"using BlockData::operator=;");
   else if (per.isDataNode)
      out(1,"using DataNode::operator=;");

   // output: defaults (applicable only to metadata)
   size_t ndefaults = 0;
   for (const auto &m : per.metadata)
      if (m.isDefaulted)
         ++ndefaults;
   if (ndefaults > 0) {
      out();
      out(1,"// defaults");
      out(1,"static inline const struct Defaults {");
      for (const auto &m : per.metadata)
         if (m.isDefaulted)
            out(2,"static inline const @ @ = @;",
                m.type, m.name, initializer(m));
      out(1,"} defaults;");
   }

   // section: data members
   out();
   out(1,smallComment);
   out(1,"// Data members");
   out(1,smallComment);

   // output: comment
   out();
   out(1,"// comment");
   out(1,"Field<std::vector<std::string>> comment{this};");

   // output: fields
   writeClassContentMetadata(out, per, title);
   writeClassContentChildren(out, per);
   writeClassContentVariants(out, per);

   // output: data string or vector reference, if applicable
   if (per.isDataNode) {
      if (per.isDataString) {
         out();
         out(1,"// data");
         out(1,"std::string &string = *this;");
      } else {
         auto it = nameMap.find(per.elementType);
         if (it != nameMap.end()) {
            out();
            out(1,"// data");
            out(1,"std::vector<@> &@ = *this;",
                it->second.first, it->second.second);
         } else {
            // This would mean either than our nameMap is missing something that
            // it ought to have, or that we're dealing with one of those dynamic
            // GNDS valueType-typed vectors, which is probably something we
            // should try to avoid dealing with. Perhaps, here, in the event
            // that we want anything in such a case, we'd make it a variant &
            // to the variant in the base BodyText.
         }
      }
   }

   // output: shortcuts
   if (per.name2path.size()) {
      out();
      out(1,"// shortcuts");
      out(1,"#define NJOY_GNDSTK_SHORTCUT(to,name) "
          "decltype(to.name) &name = to.name");

      for (const auto &cut : per.name2path) {
         const std::string &name = cut.first;
         const std::vector<std::string> &path = cut.second;
         std::string full;
         for (const std::string &field : path)
            full += field + "().";
         full.pop_back(); // trailing '.'
         out(1,"NJOY_GNDSTK_SHORTCUT(@,@);", full, name);
      }

      out(1,"#undef NJOY_GNDSTK_SHORTCUT");
   }

   // output: constructors
   out();
   out(1,smallComment);
   out(1,"// Constructors");
   out(1,smallComment);
   writeClassCtors(out, per);

   // output: class end
   writeClassSuffix(out, per, specs);

   // done
   code = out.str();
} // writeClass


// -----------------------------------------------------------------------------
// Miscellaneous functions for getting JSON content
// -----------------------------------------------------------------------------

// readJSONFile
json::object readJSONFile(const std::string &file, const bool print = false)
{
   // Depending on the call context, we might or might not print the file name
   if (print) {
      const std::string f = beginsin(file,"./") ? std::string(&file[2]) : file;
      std::cout << color::custom::purple << f << color::reset << std::endl;
   }

   std::ifstream ifs(file);
   if (!ifs) {
      log::error("Could not open file \"{}\"", file);
      throw std::exception{};
   }

   json::object j;
   ifs >> j;
   return j;
} // readJSONFile


// getMetadataJSON
json::object getMetadataJSON(const json::object &j)
{
   static const std::string metastr = "metadata";
   static const std::string attrstr = "attributes";
   const bool meta = j.contains(metastr);
   const bool attr = j.contains(attrstr);

   // not both
   assert(!(meta && attr));

   return
      meta ? j[metastr].get<json::object>()
    : attr ? j[attrstr].get<json::object>()
    : json::object{};
} // getMetadataJSON


// getChildrenJSON
json::object getChildrenJSON(const json::object &j)
{
   static const std::string chldstr = "children";
   static const std::string nodestr = "childNodes";
   const bool chld = j.contains(chldstr);
   const bool node = j.contains(nodestr);

   // not both
   assert(!(chld && node));

   return
      chld ? j[chldstr].get<json::object>()
    : node ? j[nodestr].get<json::object>()
    : json::object{};
} // getChildrenJSON


// -----------------------------------------------------------------------------
// commandLine and its helper functions
// -----------------------------------------------------------------------------

// readChangesFile
void readChangesFile(const std::string &file, InfoSpecs &specs)
{
   const json::object jchanges = readJSONFile(file);
   using pair = std::pair<std::string,std::string>;

   // Changes to name?
   if (jchanges.contains("name"))
      for (const auto &item : jchanges["name"].items())
         if (!isComment(item.first))
            specs.mapName.insert(pair(item.first,item.second.get<json::string>()));

   // Changes to metadata/attributes?
   const json::object metadata = getMetadataJSON(jchanges);

   // from/to pairs for "type"
   if (metadata.contains("type"))
      for (const auto &item : metadata["type"].items())
         if (!isComment(item.first))
            specs.mapMetaType.insert(pair(item.first,item.second.get<json::string>()));
   // from/to pairs for "default"
   if (metadata.contains("default"))
      for (const auto &item : metadata["default"].items())
         if (!isComment(item.first))
            specs.mapMetaDefault.insert(pair(item.first,item.second.get<json::string>()));
} // readChangesFile


// printSingletons
void printSingletons(const std::string &file)
{
   const json::object &jfile = readJSONFile(file,true);

   for (const auto &item : jfile.items()) {
      if (beginsin(item.first, "//"))
         continue;
      if (!item.second.has<json::object>())
         continue;
      const json::object &rhs = item.second.get<json::object>();

      if (!isClass(item))
         continue;

      const bool hasdata =
         (rhs.contains("string"  ) && !rhs["string"  ].is_null()) ||
         (rhs.contains("vector"  ) && !rhs["vector"  ].is_null()) ||
         (rhs.contains("bodyText") && !rhs["bodyText"].is_null());

      const json::object metadata = getMetadataJSON(rhs);
      const json::object children = getChildrenJSON(rhs);

      const std::string parent = item.first;
      if (metadata.size() == 0 && children.size() == 1 && !hasdata)
         std::cout
            << color::custom::green
            << "   Entry has no metadata or data, and just one child: "
            << color::custom::blue << parent << color::reset << std::endl;
      if (metadata.size() == 0 && children.size() == 0 && !hasdata)
         std::cout
            << color::custom::yellow
            << "   Entry has no metadata, data, or children: "
            << color::custom::blue << parent << color::reset << std::endl;
   }
} // printSingletons


// commandLine
// Gather information from the JSON file given on the command line
void commandLine(
   const int argc, const char *const *const argv,
   InfoSpecs &specs
) {
   // Usage
   if (argc < 2) {
      std::cout << "Usage: " << argv[0] << " file.json" << std::endl;
      exit(EXIT_FAILURE);
   }

   // Input file
   const json::object jmain = readJSONFile(argv[1]);

   // JSON keys we'll look for
   static const std::string path    = "Path";
   static const std::string project = "Project";
   static const std::string version = "Version";
   static const std::string input   = "JSONDir";
   static const std::string files   = "JSONFiles";
   static const std::string changes = "Changes";

   // Need "Version"
   if (!jmain.contains(version)) {
      log::error("The input JSON file needs {}", version);
      throw std::exception{};
   }

   // Need "JSONFiles"
   if (!jmain.contains(files)) {
      log::error("The input JSON file needs {}", files);
      throw std::exception{};
   }

   // Extract information from the command line JSON file...
   // ...these are optional:
   specs.Path    = jmain.contains(path   ) ? jmain[path   ].get<json::string>() : ".";
   specs.Project = jmain.contains(project) ? jmain[project].get<json::string>() : "GNDStk";
   specs.JSONDir = jmain.contains(input  ) ? jmain[input  ].get<json::string>() : ".";
   // ...these are required:
   specs.Version = jmain[version].get<json::string>();
   for (const auto &str : jmain[files].get<json::array>())
      specs.JSONFiles.push_back(str.get<json::string>());

   // Version, with '_'s in place of '.'s
   specs.VersionUnderscore = replace(specs.Version, '.', '_');

   // Prepend the JSON file names with their directory
   for (std::string &file : specs.JSONFiles)
      file = specs.JSONDir + '/' + file;

   // File names...

   // For C++
   const std::string cbase =
      specs.Path + "/" + specs.Project + "/src/" + specs.Project + "/";
   specs.hppVersion = cbase + specs.Version + ".hpp";
   specs.hppKey     = cbase + specs.Version + "/key.hpp";

   // For the C interface
   const std::string cppbase = specs.Path + "/" + specs.Project + "/c/src/";
   specs.hVersion = cppbase + specs.Version + ".h";
   // We don't currently know of anything that we'd have in the following
   // file, so we won't create it. But I'll leave this in as a placeholder.
   specs.cVersion = cppbase + specs.Version + ".cpp";

   // Changes?
   if (jmain.contains(changes))
      readChangesFile(jmain[changes].get<json::string>(),specs);
} // commandLine


// -----------------------------------------------------------------------------
// preprocess* functions
// -----------------------------------------------------------------------------

// preprocessClass
void preprocessClass(
   InfoSpecs &specs, const std::string &nsname, const json::pair &keyval
) {
   // Ensure that this JSON entry represents a class - as opposed
   // to being, say, "namespace" or some other non-class entry.
   if (!isClass(keyval))
      return;

   // Get the class name, then link this class with the current namespace.
   // This information is used, later, for various purposes.
   const std::string clname = nameClass(keyval,specs);
   specs.class2nspace.insert(std::make_pair(clname,nsname));

   // ------------------------
   // Create directories
   // ------------------------

   // For the present namespace: C++, Python, and C directories. The present
   // namespace probably contains multiple classes, so these directories may
   // have been created already, but that's fine.
   const std::string nsdircpp = specs.Path + "/" + specs.Project +
      "/src/" + specs.Project + "/" + specs.Version + "/" + nsname;
   const std::string nsdirpy  = specs.Path + "/" + specs.Project +
      "/python/src/" + specs.Version + "/" + nsname;
   const std::string nsdirc   = specs.Path + "/" + specs.Project +
      "/c/src/" + specs.Version + "/" + nsname;

   // For the present class: C++ and C source and test directories.
   const std::string clsrccpp  = nsdircpp + "/" + clname + "/src";
   const std::string cltestcpp = nsdircpp + "/" + clname + "/test";
   const std::string clsrcc    = nsdirc   + "/" + clname + "/src";
   const std::string cltestc   = nsdirc   + "/" + clname + "/test";

   // Create the above directories, if (and only if) they don't already exist.
   system(("mkdir -p " + nsdircpp ).data());
   system(("mkdir -p " + nsdirpy  ).data());
   system(("mkdir -p " + nsdirc   ).data());
   system(("mkdir -p " + clsrccpp ).data());
   system(("mkdir -p " + cltestcpp).data());
   system(("mkdir -p " + clsrcc   ).data());
   system(("mkdir -p " + cltestc  ).data());

   // ------------------------
   // Create custom files
   // ------------------------

   // To allow for customization of the present class in the present namespace,
   // create certain custom.* files. Do so, however, only where any such file
   // isn't already there, or else we might be trashing someone's customization!

   // Below, the "false" parameters in the writer constructions prevent the
   // file from getting our "autogenerated, do not modify" admonishment at the
   // top. This makes sense, as the customization file are there precisely for
   // users to, well, customize.

   // C++ custom.hpp
   const std::string customhpp = clsrccpp + "/custom.hpp";
   if (!std::ifstream(customhpp)) {
      std::cout
         << color::custom::green << "   Creating " << clsrccpp + "/"
         << color::custom::blue << "custom.hpp" << color::reset << std::endl;
      writer out(customhpp,false); // false: no "file was autogenerated" message
      out();
      out(0,"private:");
      out();
      out(1,"static inline helpMap help = {};");
   }

   // As above, but for the C interface: create custom.h and custom.cpp if and
   // where they don't already exist.

   // C custom.h
   const std::string customh = clsrcc + "/custom.h";
   if (!std::ifstream(customh)) {
      std::cout
         << color::custom::green << "   Creating " << clsrcc + "/"
         << color::custom::blue << "custom.h" << color::reset << std::endl;
      writer out(customh,false);
   }

   // C custom.cpp
   // Meaning, C++ source for the C interface to call. (That is, this isn't for
   // C++ itself; remember that our C++ library is header-only.)
   const std::string customcpp = clsrcc + "/custom.cpp";
   if (!std::ifstream(customcpp)) {
      std::cout
         << color::custom::green << "   Creating " << clsrcc + "/"
         << color::custom::blue << "custom.cpp" << color::reset << std::endl;
      writer out(customcpp,false);
   }

   // ------------------------
   // Create file-name maps
   // ------------------------

   // For this namespace:
   //    The cpp file for Python
   auto ns = specs.namespace2data.insert(std::make_pair(nsname,PerNamespace{}));
   ns.first->second.cppPython = nsdirpy + ".python.cpp";
   ns.first->second.nsname = nsname;

   // For this namespace::class:
   //    The cpp file for Python
   //    The hpp file for GNDStk
   //    The C/C++ header, and the C++ backend for the C interface
   auto cl = specs.class2data.insert(
      std::make_pair(NamespaceAndClass{nsname,clname}, PerClass{}));
   assert(cl.second); // should have been inserted - not there already
   cl.first->second.cppPython = nsdirpy  + "/" + clname + ".python.cpp";
   cl.first->second.hppGNDStk = nsdircpp + "/" + clname + ".hpp";
   cl.first->second.headerC   = nsdirc   + "/" + clname + ".h";
   cl.first->second.sourceC   = nsdirc   + "/" + clname + ".cpp";
} // preprocessClass


// preprocessFiles
// This reads the JSON spec files and collects preliminary information that's
// used, later, when the spec files are processed in more detail. (Detailed
// processing requires knowledge obtained from this preliminary pass, which is
// why these things are done separately.) This preliminary processing includes
// creating a class-to-namespace map; creating directories into which output
// files will be placed; creating class-specific customization files when it's
// appropriate to do so; and creating maps from namespace to namespace-specific
// information, and from namespace::class to class-specific information. File
// names are computed as part of the "information" for the maps just mentioned.
void preprocessFiles(InfoSpecs &specs)
{
   // files
   for (const std::string &file : specs.JSONFiles) {
      const json::object jmain = readJSONFile(file,true);
      const std::string nsname = getFileNamespace(jmain);
      // classes in the file
      for (const auto &cl : jmain.items())
         preprocessClass(specs, nsname, cl);
   }
} // preprocessFiles


// -----------------------------------------------------------------------------
// validate*
// getClass
// getFilesAndClasses
// -----------------------------------------------------------------------------

// Helper: validateMetadata
void validateMetadata(const json::object &metadata)
{
   for (const auto &field : metadata.items()) {
      if (beginsin(field.first, "//"))
         continue;
      assert(field.second.contains("type"));
      assert(field.second.contains("required"));
   }
}


// Helper: validateChildren
void validateChildren(const json::object &children, const PerClass &per)
{
   for (const auto &field : children.items()) {
      if (beginsin(field.first, "//"))
         continue;
      assert(field.second.contains("required"));

      // Consistency check: certain occurrence values imply *not* required.
      // Remark: the GNDS manual speaks of "choice2" and "choice2+" options
      // for occurrence. We're not sure if those will remain in future GNDS
      // specifications, so we won't worry now about how they might fit in.
      const std::string &times = getTimes(per,field.first,field.second.get<json::object>());
      if (times == "0+" || times == "choice" || times == "choice+")
         assert(!field.second["required"].get<json::boolean>()); // not required

      if (debugging) {
         const std::string key  = field.first;
         const std::string name = field.second.contains("name")
            ? field.second["name"].get<json::string>()
            : key;
         std::cout
            << "child:  "
            << std::setw(20) << std::left << per.nsname << " "
            << std::setw(48) << std::left << per.clname << " "
            << std::setw(48) << std::left << key << " "
            << (key == name ? " " : "*")  << " "
            << std::left << name << std::endl;
      }
   }
}


// getClass
void getClass(
   InfoSpecs &specs, const std::string &nsname, const json::pair &keyval
) {
   if (!isClass(keyval))
      return;
   const std::string clname = nameClass(keyval,specs);

   // find in class map
   const auto it = specs.class2data.find(NamespaceAndClass(nsname,clname));
   PerClass &per = it->second;

   // collect dependencies, for the present class, as this function proceeds
   Class2Dependencies dep;
   dep.theClass = NamespaceAndClass(nsname,clname);

   // names
   per.nsname = nsname;
   per.clname = clname;
   per.nameGNDS = nameGNDS(keyval,nsname,true);

   // metadata/children information
   const json::object &classRHS = keyval.second.get<json::object>();
   const json::object attrs = getMetadataJSON(classRHS);
   const json::object elems = getChildrenJSON(classRHS);
   validateMetadata(attrs);
   validateChildren(elems, per);
   getClassMetadata(attrs, specs, per);
   getClassChildren(elems, specs, per, dep);
   getClassVariants(elems, specs, per, dep);

   // data-node information
   const bool
      str  = classRHS.contains("string"  ) && !classRHS["string"  ].is_null(),
      vec  = classRHS.contains("vector"  ) && !classRHS["vector"  ].is_null(),
      body = classRHS.contains("bodyText") && !classRHS["bodyText"].is_null();
   assert(int(str) + int(vec) + int(body) <= 1); // no more than one

   per.isDataString = str;
   per.isDataVector = vec || body;
   if (vec) {
      // A type change, as with metadata, may be warranted here as well
      const std::string type = classRHS["vector"].get<json::string>();
      const auto it = specs.mapMetaType.find(type);
      per.elementType = it == specs.mapMetaType.end() ? type : it->second;
   } else
      per.elementType = "";
   per.isDataNode =
      per.isDataString || (per.isDataVector && per.elementType != "");
   per.cdata = classRHS.contains("cdata") && classRHS["cdata"].get<json::boolean>();

   // save dependencies
   specs.ClassDependenciesRaw.push_back(dep);
} // getClass


// getFilesAndClasses
void getFilesAndClasses(InfoSpecs &specs)
{
   // each file
   for (const std::string &file : specs.JSONFiles) {
      const json::object jmain = readJSONFile(file);
      const std::string nsname = getFileNamespace(jmain);
      // each class
      for (const auto &cl : jmain.items())
         getClass(specs, nsname, cl);
   }
} // getFilesAndClasses


// -----------------------------------------------------------------------------
// Functions relating to our topological sort
// Adapted from: http://coliru.stacked-crooked.com/a/7c0bf8d3443b804d
// -----------------------------------------------------------------------------

// insertDependency
void insertDependency(
   const NamespaceAndClass &wanted,
   std::vector<Class2Dependencies> &vecSource,
   std::vector<Class2Dependencies> &vecTarget
) {
   const auto iter = std::find_if(
      vecSource.begin(), vecSource.end(),
     [wanted](const Class2Dependencies &c2d) { return c2d.theClass == wanted; }
   );

   if (iter != vecSource.end()) {
      const Class2Dependencies c2d = *iter;
      vecSource.erase(iter);
      for (const NamespaceAndClass &dep : c2d.dependencies)
         insertDependency(dep, vecSource, vecTarget);
      vecTarget.push_back(c2d);
   }
}

// sortDependencies
void sortDependencies(InfoSpecs &specs)
{
   while (specs.ClassDependenciesRaw.size() > 0)
      insertDependency(
         specs.ClassDependenciesRaw.begin()->theClass,
         specs.ClassDependenciesRaw,
         specs.ClassDependenciesSorted);
}


// -----------------------------------------------------------------------------
// For the C++ header files
// fileGNDStkVersion
// fileGNDStkKey
// fileGNDStkClass
// -----------------------------------------------------------------------------

// ------------------------
// fileGNDStkVersion
// ------------------------

void fileGNDStkVersion(const InfoSpecs &specs)
{
   // ------------------------
   // Create a C++ header
   // for this version
   // ------------------------

   {
      writer out(specs.hppVersion);
      out();
      out("#ifndef @_@",
          allcaps(specs.Project), allcaps(specs.VersionUnderscore));
      out("#define @_@",
          allcaps(specs.Project), allcaps(specs.VersionUnderscore));

      std::string nsname_last = "";
      for (const auto &c : specs.class2data) {
         const std::string nsname = c.first.nsname;
         const std::string clname = c.first.clname;
         if (nsname != nsname_last)
            out();
         nsname_last = nsname;
         out("#include \"@/@/@/@.hpp\"",
             specs.Project, specs.Version, nsname, clname);
      }

      out();
      out("#endif");
   }

   // ------------------------
   // Create a C/C++ header
   // for the C interface
   // ------------------------

   {
      writer out(specs.hVersion);
      out();
      out(largeComment);
      out("// This header file is designed to work with both C and C++");
      out(largeComment);
      out();
      out("#ifndef C_INTERFACE_@_@",
          allcaps(specs.Project), allcaps(specs.VersionUnderscore));
      out("#define C_INTERFACE_@_@",
          allcaps(specs.Project), allcaps(specs.VersionUnderscore));

      out();
      out("#include \"GNDStk.h\"");
      out();
      out("#ifdef __cplusplus");
      out(1,"// For C++");
      out(1,"#include \"@/@.hpp\"", specs.Project, specs.Version);
      out("#endif");

      std::string nsname_last = "";
      for (const auto &c : specs.class2data) {
         const std::string nsname = c.first.nsname;
         const std::string clname = c.first.clname;
         if (nsname != nsname_last)
            out();
         nsname_last = nsname;
         out("#include \"@/@/@.h\"", specs.Version, nsname, clname);
      }

      out();
      out("#endif");
   }
} // fileGNDStkVersion


// ------------------------
// fileGNDStkKey
// ------------------------

void fileGNDStkKey(const InfoSpecs &specs)
{
   // ------------------------
   // Gather information
   // ------------------------

   // pair: key name, GNDS name
   using pair = std::pair<std::string, std::string>;

   // For metadata, collect into one place
   std::set<pair> metadata;

   // For children, process on a per-file basis; *multi*map is
   // in case the same namespace appears in more than one file.
   // The multimap contains: namespace name, set<pair>
   std::multimap<std::string, std::set<pair>> namespace2children;

   for (const auto &file : specs.JSONFiles) {
      const json::object jmain = readJSONFile(file);
      auto it = namespace2children.insert(
         std::make_pair(getFileNamespace(jmain),std::set<pair>{}));

      for (const auto &node : jmain.items()) {
         if (isClass(node)) {
            // nodes ==> children
            it->second.insert(std::make_pair(
               nameField(node,specs),
               nameGNDS(node)));

            // attributes ==> metadata
            const json::object attrs = getMetadataJSON(node.second.get<json::object>());
            for (const auto &attr : attrs.items()) {
               if (beginsin(attr.first, "//"))
                  continue;
               metadata.insert(std::make_pair(
                  nameField(attr,specs),
                  nameGNDS(attr)));
            }
         }
      }
   }

   // ------------------------
   // comment, macro guard,
   // outer namespaces
   // ------------------------

   writer out(specs.hppKey);
   out();
   out("#ifndef @_@_KEY",
       allcaps(specs.Project), allcaps(specs.VersionUnderscore));
   out("#define @_@_KEY",
       allcaps(specs.Project), allcaps(specs.VersionUnderscore));
   out();
   out("// GNDStk Core Interface");
   out("#include \"GNDStk.hpp\"");
   out();
   if (specs.Project == "GNDStk") // <== use namespace njoy only for this
      out("namespace njoy {");
   out("namespace @ {", specs.Project);
   out("namespace @ {", specs.VersionUnderscore);
   out();
   out("using namespace njoy;");
   out("using namespace GNDStk;");

   // ------------------------
   // Meta<> objects
   // ------------------------

   section(out,"// meta::");
   out();
   out("namespace meta {");

   if (metadata.size() > 0) {
      out();
      out(0,"#define NJOY_GNDSTK_MAKE_LOOKUP(nameField,nameGNDS) \\");
      out(1,"inline const auto nameField = makeLookup( \\");
      out(2,"#nameGNDS, \\");
      out(2,"[](const auto &obj) -> decltype(obj.nameField()) \\");
      out(2,"{ \\");
      out(3,"return obj.nameField(); \\");
      out(2,"} \\");
      out(1,")");
      out(0,"// nameField vs. nameGNDS: e.g. Double, vs. double in GNDS; "
          "usually identical");
      out();
      for (const auto &meta : metadata)
         out("NJOY_GNDSTK_MAKE_LOOKUP(@,@);", meta.first, meta.second);
      out();
      out(0,"#undef NJOY_GNDSTK_MAKE_LOOKUP");
      out();
   }

   out("} // namespace meta");

   // ------------------------
   // Child<> objects
   // ------------------------

   for (const auto &nspace : namespace2children) {
      section(out, "// @::child::", nspace.first);
      out();
      out("namespace @ {", nspace.first);
      out("namespace child {");

      const auto &children = nspace.second;
      if (children.size() > 0) {
         out();
         for (const auto &child : children)
            out("inline const Child<> @(\"@\");", child.first, child.second);
         out();
      }

      out("} // namespace child");
      out("using namespace child;");
      out("} // namespace @", nspace.first);
   }

   // ------------------------
   // Using directives
   // ------------------------

   section(out, "// For convenience: using directives");
   out();
   out("namespace key {");
   out(1,"using namespace meta;");
   for (const auto &nspace : namespace2children)
      out(1,"using namespace @::child;", nspace.first);
   out("} // namespace key");
   out();
   out("using namespace key;");
   for (const auto &nspace : namespace2children)
      out("using namespace @;", nspace.first);

   // ------------------------
   // finish
   // ------------------------

   out();
   out();
   out(largeComment);
   out(largeComment);
   out();
   out("} // namespace @", specs.VersionUnderscore);
   out("} // namespace @", specs.Project);
   if (specs.Project == "GNDStk") // <== end namespace njoy only for this
      out("} // namespace njoy");
   out();
   out("#endif");
} // fileGNDStkKey


// ------------------------
// fileGNDStkClass
// ------------------------

void fileGNDStkClass(
   const InfoSpecs &specs, const PerClass &per, const Class2Dependencies &c2d
) {
   // class-specific hpp file
   writer out(per.hppGNDStk);
   const std::string guard =
      allcaps(specs.Project) + "_" +
      allcaps(specs.VersionUnderscore) + "_" +
      allcaps(per.nsname) + "_" +
      allcaps(per.clname);

   out();
   out("#ifndef @", guard);
   out("#define @", guard);

   out();
   if (c2d.dependencies.size() == 0) // <== otherwise, comes in through deps
      out("#include \"@/@/key.hpp\"", specs.Project, specs.Version);
   for (const auto &dep : c2d.dependencies)
      out("#include \"@/@/@/@.hpp\"",
          specs.Project, specs.Version, dep.nsname, dep.clname);

   out();
   if (specs.Project == "GNDStk")
      out("namespace njoy {");
   out("namespace @ {", specs.Project);
   out("namespace @ {", specs.VersionUnderscore);
   out(per.code,false);
   out("} // namespace @", specs.VersionUnderscore);
   out("} // namespace @", specs.Project);
   if (specs.Project == "GNDStk")
      out("} // namespace njoy");
   out();
   out("#endif");
} // fileGNDStkClass


// -----------------------------------------------------------------------------
// C interface:
// Helpers
// -----------------------------------------------------------------------------

// two
// Forward args to two places: header and source
template<class... Ts>
void two(writer &hdr, writer &src, Ts &&...args)
{
   hdr(std::forward<Ts>(args)...);
   src(std::forward<Ts>(args)...);
}

// ext
// For writing (or not writing) 'extern "C"'
template<class... Ts>
void ext(writer &hdr, writer &src, const std::string &str, Ts &&...args)
{
   hdr("extern_c "+str, std::forward<Ts>(args)...);
   src(            str, std::forward<Ts>(args)...);
}

// ppp
// Comment, prefixed in header file with "+++"
template<class... Ts>
void ppp(writer &hdr, writer &src, const std::string &str, Ts &&...args)
{
   hdr("// +++ "+str, std::forward<Ts>(args)...);
   src("// "    +str, std::forward<Ts>(args)...);
}
template<class... Ts>
void PPP(writer &hdr, writer &src, Ts &&...args)
{
   two(hdr,src);
   ppp(hdr,src,std::forward<Ts>(args)...);
}

// mmm
// Comment, prefixed in header file with "---"
template<class... Ts>
void mmm(writer &hdr, writer &src, const std::string &str, Ts &&...args)
{
   hdr("// --- "+str, std::forward<Ts>(args)...);
   src("// "    +str, std::forward<Ts>(args)...);
}
template<class... Ts>
void MMM(writer &hdr, writer &src, Ts &&...args)
{
   two(hdr,src);
   mmm(hdr,src,std::forward<Ts>(args)...);
}

// sig
// End C interface function signature; style dependent on hadFields bool
void sig(writer &hdr, writer &src, const bool hadFields = false)
{
   // header: end of parameters, semicolon for declaration
   hdr(");");
   // source: end of parameters, left brace for definition
   src(hadFields ? ") {" : ")\n{");
}

// mtype_param
// Get metadata type, for C interface
std::string mtype_param(const InfoMetadata &m)
{
   return m.type == "std::string"
      ? "char *const"
      : m.type;
}

// mtype_return
// Get metadata type, for C interface
std::string mtype_return(const InfoMetadata &m)
{
   return m.type == "std::string"
      ? "const char *"
      : m.type;
}

// ctype
// Get child-node type, for C interface
std::string ctype(const InfoChildren &c)
{
   // Why not ...2Const... in the first case? See:
   //    https://stackoverflow.com/questions/5055655
   // and:
   //    https://c-faq.com/ansi/constmismatch.html
   // Remember that we're generating C code here, not C++ code.
   return c.isVector
      ? "ConstHandle2" + c.plain + " *const"
      : "ConstHandle2Const" + c.plain;
}

// section
template<class... Ts>
void section(writer &hdr, writer &src, const std::string &str, Ts &&...args)
{
   two(hdr,src);
   two(hdr,src);
   two(hdr,src,largeComment);
   two(hdr,src,str, std::forward<Ts>(args)...);
   two(hdr,src,largeComment);
}


// -----------------------------------------------------------------------------
// C interface:
// fileCInterfaceCreate*
// -----------------------------------------------------------------------------

// fileCInterfaceCreateParams
void fileCInterfaceCreateParams(writer &hdr, writer &src, const PerClass &per)
{
   int count = 0;
   const int total = per.nfields();

   // metadata
   for (const auto &m : per.metadata) {
      two(hdr,src);
      two(hdr,src,1,"const @ @@",
          mtype_param(m),
          m.name,
          ++count < total ? "," : "",
          false);
   }

   // children
   for (const auto &c : per.children) {
      two(hdr,src);
      two(hdr,src,1,"@ @@@",
          ctype(c),
          c.name,
          c.isVector ? ", const size_t "+c.name+"Size" : "",
          ++count < total ? "," : "",
          false
      );
   }

   // variants
   // todo

   if (total)
      two(hdr,src);
}

// fileCInterfaceCreateCall
void fileCInterfaceCreateCall(writer &hdr, writer &src, const PerClass &per)
{
   // metadata
   for (const auto &m : per.metadata) {
      src(",");
      src(2,"@", m.name, false);
   }

   // children
   for (const auto &c : per.children) {
      src(",");
      const std::string Child = c.plain;
      const std::string child = c.name;
      c.isVector
         ? src(2,"std::vector<CPP@>{}", Child, false)
         : src(2,"detail::tocpp<CPP@>(@)", Child, child, false);
   }

   // variants
   // todo

   src();
   src(1,");");
   for (const auto &c : per.children) {
      if (!c.isVector)
         continue;
      const std::string Child = c.plain;
      const std::string child = c.name;
      src(1,"for (size_t @N = 0; @N < @Size; ++@N)",
          Child, Child, child, Child);
      src(2,"@@Add(handle, @[@N]);",
          per.clname, Child, child, Child);
   }
   src(1,"return handle;");
   src("}");
}


// -----------------------------------------------------------------------------
// C interface:
// fileCInterfaceBasics
// -----------------------------------------------------------------------------

void fileCInterfaceBasics(writer &hdr, writer &src, const PerClass &per)
{
   // section comment
   section(hdr,src,
           "// Basics\n"
           "// Create, Assign, Delete");

   // create: default, const
   MMM(hdr,src,"Create, default, const");
   ext(hdr,src,"Handle2Const@", per.clname);
   two(hdr,src,"@DefaultConst(", per.clname, false);
   sig(hdr,src);
   src(1,"return detail::createHandle<CPP,C>");
   src(2,"(CLASSNAME, CLASSNAME+\"DefaultConst\");");
   src("}");

   // create: default, non-const
   PPP(hdr,src,"Create, default");
   ext(hdr,src,"Handle2@", per.clname);
   two(hdr,src,"@Default(", per.clname, false);
   sig(hdr,src);
   src(1,"return detail::createHandle<CPP,C>");
   src(2,"(CLASSNAME, CLASSNAME+\"Default\");");
   src("}");

   // create: general, const
   MMM(hdr,src,"Create, general, const");
   ext(hdr,src,"Handle2Const@", per.clname);
   two(hdr,src,"@CreateConst(", per.clname, false);
   fileCInterfaceCreateParams(hdr,src,per);
   sig(hdr,src, per.nfields() != 0);
   src(1,"ConstHandle2@ handle = detail::createHandle<CPP,C>(", per.clname);
   src(2,"CLASSNAME, CLASSNAME+\"CreateConst\"", false);
   fileCInterfaceCreateCall(hdr,src,per);

   // create: general, non-const
   PPP(hdr,src,"Create, general");
   ext(hdr,src,"Handle2@", per.clname);
   two(hdr,src,"@Create(", per.clname, false);
   fileCInterfaceCreateParams(hdr,src,per);
   sig(hdr,src, per.nfields() != 0);
   src(1,"ConstHandle2@ handle = detail::createHandle<CPP,C>(", per.clname);
   src(2,"CLASSNAME, CLASSNAME+\"Create\"", false);
   fileCInterfaceCreateCall(hdr,src,per);

   // assign
   PPP(hdr,src,"Assign");
   ppp(hdr,src,"Use this to assign one handled object to another. "
       "Don't assign handles,");
   ppp(hdr,src,"as with to = from. That has a meaning that you probably "
       "don't intend.");
   ext(hdr,src,"void");
   two(hdr,src,"@Assign(", per.clname, false);
   two(hdr,src,"ConstHandle2@ self, ConstHandle2Const@ from",
       per.clname, per.clname, false);
   sig(hdr,src);
   src(1,"detail::assignHandle<CPP,C>");
   src(2,"(CLASSNAME, CLASSNAME+\"Assign\", self, from);");
   src("}");

   // delete
   PPP(hdr,src,"Delete");
   ppp(hdr,src,"We'll attempt to remove no-longer-used objects "
       "automatically, but you");
   ppp(hdr,src,"may improve performance if you delete them when "
       "you're done with them.");
   ext(hdr,src,"void");
   two(hdr,src,"@Delete(", per.clname, false);
   two(hdr,src,"ConstHandle2Const@ self", per.clname, false);
   sig(hdr,src);
   src(1,"detail::deleteHandle<CPP,C>");
   src(2,"(CLASSNAME, CLASSNAME+\"Delete\", self);");
   src("}");
} // fileCInterfaceBasics


// -----------------------------------------------------------------------------
// C interface:
// fileCInterfaceIO
// -----------------------------------------------------------------------------

void fileCInterfaceIO(writer &hdr, writer &src, const PerClass &per)
{
   // section comment
   section(hdr,src,
           "// I/O\n"
           "// Read, Write, Print\n"
           "// Each returns 0 if failure, 1 if success.");

   // read from file
   PPP(hdr,src,"Read from file");
   ppp(hdr,src,"File can be XML, JSON, or HDF5.");
   ppp(hdr,src,"We'll examine the file's contents to determine "
       "its type automatically.");
   ext(hdr,src,"int");
   two(hdr,src,"@Read(", per.clname, false);
   two(hdr,src,"ConstHandle2@ self, const char *const filename",
       per.clname, false);
   sig(hdr,src);
   src(1,"return detail::readHandle<CPP,C>");
   src(2,"(CLASSNAME, CLASSNAME+\"Read\", self, filename);");
   src("}");

   // write to file
   PPP(hdr,src,"Write to file");
   ppp(hdr,src,"File can be XML, JSON, or HDF5.");
   ppp(hdr,src,"We'll use filename's extension to determine "
       "the type you want written.");
   ext(hdr,src,"int");
   two(hdr,src,"@Write(", per.clname, false);
   two(hdr,src,"ConstHandle2Const@ self, const char *const filename",
       per.clname, false);
   sig(hdr,src);
   src(1,"return detail::writeHandle<CPP,C>");
   src(2,"(CLASSNAME, CLASSNAME+\"Write\", self, filename);");
   src("}");

   // print
   PPP(hdr,src,"Print to standard output, in our prettyprinting format");
   ext(hdr,src,"int");
   two(hdr,src,"@Print(", per.clname, false);
   two(hdr,src,"ConstHandle2Const@ self", per.clname, false);
   sig(hdr,src);
   src(1,"return detail::printHandle<CPP,C>");
   src(2,"(CLASSNAME, CLASSNAME+\"Print\", self);");
   src("}");

   // print, XML
   PPP(hdr,src,"Print to standard output, as XML");
   ext(hdr,src,"int");
   two(hdr,src,"@PrintXML(", per.clname, false);
   two(hdr,src,"ConstHandle2Const@ self", per.clname, false);
   sig(hdr,src);
   src(1,"return detail::printHandle<CPP,C>");
   src(2,"(CLASSNAME, CLASSNAME+\"PrintXML\", self, \"XML\");");
   src("}");

   // print, JSON
   PPP(hdr,src,"Print to standard output, as JSON");
   ext(hdr,src,"int");
   two(hdr,src,"@PrintJSON(", per.clname, false);
   two(hdr,src,"ConstHandle2Const@ self", per.clname, false);
   sig(hdr,src);
   src(1,"return detail::printHandle<CPP,C>");
   src(2,"(CLASSNAME, CLASSNAME+\"PrintJSON\", self, \"JSON\");");
   src("}");
} // fileCInterfaceIO


// -----------------------------------------------------------------------------
// C interface:
// fileCInterfaceVector
// -----------------------------------------------------------------------------

void fileCInterfaceVector(
   writer &hdr, writer &src,
   const PerClass &per, const std::string &type,
   const bool isSection = true
) {
   // section comment
   if (isSection)
      section(hdr,src,"// Data vector");
   else {
      assert(type != "");
      two(hdr,src);
      two(hdr,src,smallComment);
      two(hdr,src,"// @", type);
      two(hdr,src,smallComment);
   }

   // dynamic type?
   if (type == "") {
      // for a C interface, these are probably sufficient
      fileCInterfaceVector(hdr,src,per,"int",     false);
      fileCInterfaceVector(hdr,src,per,"unsigned",false);
      fileCInterfaceVector(hdr,src,per,"float",   false);
      fileCInterfaceVector(hdr,src,per,"double",  false);
      return;
   }

   // Example:
   //    type:  "double" (parameter to the present function)
   //    Class: "Foobar" (class type; for brevity)
   //    types: "doubles"
   //    Types: "Doubles"
   const std::string Class = per.clname;
   const std::string types = type + 's';
   const std::string Types = capital(type) + 's';

   PPP(hdr,src,"Clear");
   ext(hdr,src,"void");
   two(hdr,src,"@@Clear(", Class, Types, false);
   two(hdr,src,"ConstHandle2@ self", Class, false);
   sig(hdr,src);
   src(1,"detail::vectorClear<CPP>");
   src(2,"(CLASSNAME, CLASSNAME+\"@Clear\", self);", Types);
   src("}");

   PPP(hdr,src,"Get size");
   ext(hdr,src,"size_t");
   two(hdr,src,"@@Size(", Class, Types, false);
   two(hdr,src,"ConstHandle2Const@ self", Class, false);
   sig(hdr,src);
   src(1,"return detail::vectorSize<CPP>");
   src(2,"(CLASSNAME, CLASSNAME+\"@Size\", self);", Types);
   src("}");

   PPP(hdr,src,"Get value");
   ppp(hdr,src,"By index \\in [0,size)");
   ext(hdr,src,"@", type);
   two(hdr,src,"@@Get(", Class, Types, false);
   two(hdr,src,"ConstHandle2Const@ self, const size_t index", Class, false);
   sig(hdr,src);
   src(1,"return detail::vectorGet<CPP,@>", type);
   src(2,"(CLASSNAME, CLASSNAME+\"@Get\", self, index);", Types);
   src("}");

   PPP(hdr,src,"Set value");
   ppp(hdr,src,"By index \\in [0,size)");
   ext(hdr,src,"void");
   two(hdr,src,"@@Set(", Class, Types, false);
   two(hdr,src,"ConstHandle2@ self, const size_t index, const @ value",
       Class, type, false);
   sig(hdr,src);
   src(1,"detail::vectorSet<CPP,@>", type);
   src(2,"(CLASSNAME, CLASSNAME+\"@Set\", self, index, value);", Types);
   src("}");

   MMM(hdr,src,"Get pointer to existing values, const");
   ext(hdr,src,"const @ *", type);
   two(hdr,src,"@@GetArrayConst(", Class, Types, false);
   two(hdr,src,"ConstHandle2Const@ self", Class, false);
   sig(hdr,src);
   src(1,"return detail::vectorGet<CPP,@>", type);
   src(2,"(CLASSNAME, CLASSNAME+\"@GetArrayConst\", self);", Types);
   src("}");

   PPP(hdr,src,"Get pointer to existing values, non-const");
   ext(hdr,src,"@ *", type);
   two(hdr,src,"@@GetArray(", Class, Types, false);
   two(hdr,src,"ConstHandle2@ self", Class, false);
   sig(hdr,src);
   src(1,"return detail::vectorGet<CPP,@>", type);
   src(2,"(CLASSNAME, CLASSNAME+\"@GetArray\", self);", Types);
   src("}");

   PPP(hdr,src,"Set completely new values and size");
   ext(hdr,src,"void");
   two(hdr,src,"@@SetArray(", Class, Types, false);
   two(hdr,src,"ConstHandle2@ self, const @ *const values, const size_t size",
       Class, type, false);
   sig(hdr,src);
   src(1,"return detail::vectorSet<CPP,@>", type);
   src(2,"(CLASSNAME, CLASSNAME+\"@SetArray\", self, size, values);", Types);
   src("}");
} // fileCInterfaceVector


// -----------------------------------------------------------------------------
// C interface:
// fileCInterfaceMeta
// -----------------------------------------------------------------------------

void fileCInterfaceMeta(
   writer &hdr, writer &src,
   const PerClass &per, const InfoMetadata &m
) {
   const std::string Class = per.clname;
   const std::string Meta  = UpperCamel(m.name);
   const std::string meta  = m.name;

   // section comment
   section(hdr,src,"// Metadatum: @", meta);

   // has
   // if (m.isOptional) // <== may or may not want this
   {
      PPP(hdr,src,"Has");
      ext(hdr,src,"int");
      two(hdr,src,"@@Has(", Class, Meta, false);
      two(hdr,src,"ConstHandle2Const@ self", Class, false);
      sig(hdr,src);
      src(1,"return detail::hasField<CPP>");
      src(2,"(CLASSNAME, CLASSNAME+\"@Has\", self, extract::@);", Meta, meta);
      src("}");
   }

   // get
   PPP(hdr,src,"Get");
   ppp(hdr,src,"Returns by value");
   ext(hdr,src,"@", mtype_return(m));
   two(hdr,src,"@@Get(", Class, Meta, false);
   two(hdr,src,"ConstHandle2Const@ self", Class, false);
   sig(hdr,src);
   src(1,"return detail::getField<CPP>");
   src(2,"(CLASSNAME, CLASSNAME+\"@Get\", self, extract::@);", Meta, meta);
   src("}");

   // set
   PPP(hdr,src,"Set");
   ext(hdr,src,"void");
   two(hdr,src,"@@Set(", Class, Meta, false);
   two(hdr,src,"ConstHandle2@ self, const @ @",
       Class, mtype_param(m), meta, false);
   sig(hdr,src);
   src(1,"detail::setField<CPP>");
   src(2,"(CLASSNAME, CLASSNAME+\"@Set\", self, extract::@, @);",
       Meta, meta, meta);
   src("}");
}


// -----------------------------------------------------------------------------
// C interface:
// fileCInterfaceChild
// -----------------------------------------------------------------------------

void fileCInterfaceChild(
   writer &hdr, writer &src,
   const InfoSpecs &specs,
   const PerClass &per, const InfoChildren &c
) {
   const std::string Class = per.clname;
   const std::string Child = c.plain;
   const std::string child = c.name;

   // section comment
   section(hdr,src,"// Child: @", child);

   // has
   // if (c.isOptional) // <== may or may not want this
   {
      PPP(hdr,src,"Has");
      ext(hdr,src,"int");
      two(hdr,src,"@@Has(", Class, Child, false);
      two(hdr,src,"ConstHandle2Const@ self", Class, false);
      sig(hdr,src);
      src(1,"return detail::hasField<CPP>");
      src(2,"(CLASSNAME, CLASSNAME+\"@Has\", self, extract::@);", Child, child);
      src("}");
   }

   // ------------------------
   // scalar case
   // ------------------------

   if (!c.isVector) {
      // get, const
      MMM(hdr,src,"Get, const");
      ext(hdr,src,"Handle2Const@", Child);
      two(hdr,src,"@@GetConst(", Class, Child, false);
      two(hdr,src,"ConstHandle2Const@ self", Class, false);
      sig(hdr,src);
      src(1,"return detail::getField<CPP,Handle2Const@>", Child);
      src(2,"(CLASSNAME, CLASSNAME+\"@GetConst\", self, extract::@);",
          Child, child);
      src("}");

      // get, non-const
      PPP(hdr,src,"Get, non-const");
      ext(hdr,src,"Handle2@", Child);
      two(hdr,src,"@@Get(", Class, Child, false);
      two(hdr,src,"ConstHandle2@ self", Class, false);
      sig(hdr,src);
      src(1,"return detail::getField<CPP,Handle2@>", Child);
      src(2,"(CLASSNAME, CLASSNAME+\"@Get\", self, extract::@);", Child, child);
      src("}");

      // set
      PPP(hdr,src,"Set");
      ext(hdr,src,"void");
      two(hdr,src,"@@Set(", Class, Child, false);
      two(hdr,src,"ConstHandle2@ self, ConstHandle2Const@ @",
          Class, Child, child, false);
      sig(hdr,src);
      src(1,"detail::setField<CPP,CPP@>", Child);
      src(2,"(CLASSNAME, CLASSNAME+\"@Set\", self, extract::@, @);",
          Child, child, child);
      src("}");

      return;
   }

   // ------------------------
   // vector case
   // ------------------------

   // clear
   PPP(hdr,src,"Clear");
   ext(hdr,src,"void");
   two(hdr,src,"@@Clear(", Class, Child, false);
   two(hdr,src,"ConstHandle2@ self", Class, false);
   sig(hdr,src);
   src(1,"detail::clearContainer<CPP>");
   src(2,"(CLASSNAME, CLASSNAME+\"@Clear\", self, extract::@);", Child, child);
   src("}");

   // size
   PPP(hdr,src,"Size");
   ext(hdr,src,"size_t");
   two(hdr,src,"@@Size(", Class, Child, false);
   two(hdr,src,"ConstHandle2Const@ self", Class, false);
   sig(hdr,src);
   src(1,"return detail::sizeOfContainer<CPP>");
   src(2,"(CLASSNAME, CLASSNAME+\"@Size\", self, extract::@);", Child, child);
   src("}");

   // add
   PPP(hdr,src,"Add");
   ext(hdr,src,"void");
   two(hdr,src,"@@Add(", Class, Child, false);
   two(hdr,src,"ConstHandle2@ self, ", Class, false);
   two(hdr,src,"ConstHandle2Const@ @", Child, child, false);
   sig(hdr,src);
   src(1,"detail::addToContainer<CPP,CPP@>", Child);
   src(2,"(CLASSNAME, CLASSNAME+\"@Add\", self, extract::@, @);",
       Child, child, child);
   src("}");

   // get, by index, const
   MMM(hdr,src,"Get, by index \\in [0,size), const");
   ext(hdr,src,"Handle2Const@", Child);
   two(hdr,src,"@@GetConst(", Class, Child, false);
   two(hdr,src,"ConstHandle2Const@ self, ", Class, false);
   two(hdr,src,"const size_t index_", false);
   sig(hdr,src);
   src(1,"return detail::getByIndex<CPP,Handle2Const@>", Child);
   src(2,"(CLASSNAME, CLASSNAME+\"@GetConst\", self, extract::@, index_);",
       Child, child);
   src("}");

   // get, by index, non-const
   PPP(hdr,src,"Get, by index \\in [0,size), non-const");
   ext(hdr,src,"Handle2@", Child);
   two(hdr,src,"@@Get(", Class, Child, false);
   two(hdr,src,"ConstHandle2@ self, ", Class, false);
   two(hdr,src,"const size_t index_", false);
   sig(hdr,src);
   src(1,"return detail::getByIndex<CPP,Handle2@>", Child);
   src(2,"(CLASSNAME, CLASSNAME+\"@Get\", self, extract::@, index_);",
       Child, child);
   src("}");

   // set, by index
   PPP(hdr,src,"Set, by index \\in [0,size)");
   ext(hdr,src,"void");
   two(hdr,src,"@@Set(", Class, Child, false);
   two(hdr,src);
   two(hdr,src,1,"ConstHandle2@ self,", Class);
   two(hdr,src,1,"const size_t index_,");
   two(hdr,src,1,"ConstHandle2Const@ @", Child, child);
   sig(hdr,src,true);
   src(1,"detail::setByIndex<CPP,CPP@>", Child);
   src(2,"(CLASSNAME, CLASSNAME+\"@Set\", self, extract::@, index_, @);",
       Child, child, child);
   src("}");

   // for this child's metadata: has, get, set
   const auto it = specs.class2data.find(NamespaceAndClass(c.ns,c.plain));
   if (it == specs.class2data.end()) {
      log::warning(
         "Unable to generate C interface has/get/set functions for:\n"
         "   class: {}::{}\n"
         "   child: {}::{}\n"
         "Child class is unknown, so its metadata for has/get/set are unknown.",
         per.nsname, Class,
         c.ns, Child
      );
      return;
   }

   for (const auto &m : it->second.metadata) {
      const std::string Meta = UpperCamel(m.name);
      const std::string meta = m.name;

      // has, by metadatum
      PPP(hdr,src,"Has, by @", meta);
      ext(hdr,src,"int");
      two(hdr,src,"@@HasBy@(", Class, Child, Meta, false);
      two(hdr,src);
      two(hdr,src,1,"ConstHandle2Const@ self,", Class);
      two(hdr,src,1,"const @ @", mtype_param(m), meta);
      sig(hdr,src,true);
      src(1,"return detail::hasByMetadatum<CPP>");
      src(2,"(CLASSNAME, CLASSNAME+\"@HasBy@\",", Child, Meta);
      src(2," self, extract::@, meta::@, @);", child, meta, meta);
      src("}");

      // get, by metadatum, const
      MMM(hdr,src,"Get, by @, const", meta);
      ext(hdr,src,"Handle2Const@", Child);
      two(hdr,src,"@@GetBy@Const(", Class, Child, Meta, false);
      two(hdr,src);
      two(hdr,src,1,"ConstHandle2Const@ self,", Class);
      two(hdr,src,1,"const @ @", mtype_param(m), meta);
      sig(hdr,src,true);
      src(1,"return detail::getByMetadatum<CPP,Handle2Const@>", Child);
      src(2,"(CLASSNAME, CLASSNAME+\"@GetBy@Const\",", Child, Meta);
      src(2," self, extract::@, meta::@, @);", child, meta, meta);
      src("}");

      // get, by metadatum, non-const
      PPP(hdr,src,"Get, by @, non-const", meta);
      ext(hdr,src,"Handle2@", Child);
      two(hdr,src,"@@GetBy@(", Class, Child, Meta, false);
      two(hdr,src);
      two(hdr,src,1,"ConstHandle2@ self,", Class);
      two(hdr,src,1,"const @ @", mtype_param(m), meta);
      sig(hdr,src,true);
      src(1,"return detail::getByMetadatum<CPP,Handle2@>", Child);
      src(2,"(CLASSNAME, CLASSNAME+\"@GetBy@\",", Child, Meta);
      src(2," self, extract::@, meta::@, @);", child, meta, meta);
      src("}");

      // set, by metadatum
      PPP(hdr,src,"Set, by @", meta);
      ext(hdr,src,"void");
      two(hdr,src,"@@SetBy@(", Class, Child, Meta, false);
      two(hdr,src);
      two(hdr,src,1,"ConstHandle2@ self,", Class);
      two(hdr,src,1,"const @ @,", mtype_param(m), meta);
      two(hdr,src,1,"ConstHandle2Const@ @", Child, child);
      sig(hdr,src,true);
      src(1,"detail::setByMetadatum<CPP,CPP@>", Child);
      src(2,"(CLASSNAME, CLASSNAME+\"@SetBy@\",", Child, Meta);
      src(2," self, extract::@, meta::@, @, @);", child, meta, meta, child);
      src("}");
   } // metadata
} // fileCInterfaceChild


// -----------------------------------------------------------------------------
// For the C interface
// -----------------------------------------------------------------------------

// ------------------------
// fileCInterfaceHeader
// ------------------------

void fileCInterfaceHeader(
   writer &hdr, const InfoSpecs &specs,
   const PerClass &per, const Class2Dependencies &c2d
) {
   // Initial remarks
   hdr();
   hdr("// Interface for C");
   hdr("// This header file is designed to work with both C and C++");
   hdr("// Function definitions are in this file's .cpp source");
   hdr();

   // Instructions
   hdr(largeComment);
   hdr(largeComment);
   hdr("// Instructions for Users");
   hdr("//");
   hdr("// Constructs you're MORE likely to care about are preceded with:");
   hdr("//    // +++ remark");
   hdr("// Constructs you're LESS likely to care about are preceded with:");
   hdr("//    // --- remark");
   hdr("// Anything not marked as above can be ignored by most users.");
   hdr("//");
   hdr("// @ is the basic handle type in this file. Example:", per.clname);
   hdr("//    // Create a default @ object:", per.clname);
   hdr("//    @ handle = @Default();", per.clname, per.clname);
   hdr("// Functions involving @ are declared throughout this file.",
       per.clname);
   hdr(largeComment);
   hdr(largeComment);

   // Preliminaries
   section(hdr, "// Preliminaries");
   const std::string guard =
      allcaps(specs.Project) + "_" +
      allcaps(specs.VersionUnderscore) + "_" +
      allcaps(per.nsname) + "_" +
      allcaps(per.clname);

   hdr();
   hdr("#ifndef C_INTERFACE_@", guard);
   hdr("#define C_INTERFACE_@", guard);
   hdr();
   hdr("#include \"GNDStk.h\"");
   for (const auto &dep : c2d.dependencies)
      hdr("#include \"@/@/@.h\"", specs.Version, dep.nsname, dep.clname);
   hdr();
   hdr("#ifdef __cplusplus");
   hdr(1,"#define extern_c extern \"C\"");
   hdr("#else");
   hdr(1,"#define extern_c");
   hdr("#endif");
   hdr();
   hdr("// Proxy C struct for the handled C++ class");
   hdr("struct @Class { };", per.clname);

   // Handle types
   section(hdr, "// Handle types");
   hdr();
   hdr("// +++ @", per.clname);
   hdr("// +++ General handle, suitable for most users. "
       "If you're not concerned about");
   hdr("// +++ strict \"const correctness\" in your C code, "
       "you can probably use this in");
   hdr("// +++ place of any function parameter of a const-aware handle type.");
   hdr("typedef struct @Class *@;", per.clname, per.clname);
   hdr();
   hdr("// --- Const-aware handles.");
   hdr("typedef const struct @Class *const ConstHandle2Const@;",
       per.clname, per.clname);
   hdr("typedef       struct @Class *const ConstHandle2@;",
       per.clname, per.clname);
   hdr("typedef const struct @Class *      Handle2Const@;",
       per.clname, per.clname);
   hdr("typedef       struct @Class *      Handle2@;",
       per.clname, per.clname);
} // fileCInterfaceHeader


// ------------------------
// fileCInterfaceSource
// ------------------------

void fileCInterfaceSource(
   writer &src, const InfoSpecs &specs,
   const PerClass &per, const Class2Dependencies &c2d
) {
   // includes
   src();
   src("#include \"@/@/@/@.hpp\"",
       specs.Project, specs.Version, per.nsname, per.clname);
   src("#include \"@.h\"", per.clname);
   src();

   // using namespace
   src("using namespace njoy::GNDStk;");
   src("using namespace @::@;", specs.Project, specs.VersionUnderscore);
   src();

   // using
   src("using C = @Class;", per.clname);
   src("using CPP = multigroup::@;", per.clname);
   src();

   // class name
   src("static const std::string CLASSNAME = \"@\";", per.clname);

   // extract: namespace begin
   if (per.nfields()) {
      src();
      src("namespace extract {");
   }

   // extract: metadata
   for (const auto &m : per.metadata)
      src(1,"static auto @ = [](auto &obj) { return &obj.@; };",
          m.name, m.name);

   // extract: children
   for (const auto &c : per.children)
      src(1,"static auto @ = [](auto &obj) { return &obj.@; };",
          c.name, c.name);

   // extract: variants
   // todo Determine how the C interface should deal with C++ variants

   // extract: namespace end
   if (per.nfields()) src("}");

   if (c2d.dependencies.size())
      src();
   for (const auto &dep : c2d.dependencies)
      src("using CPP@ = @::@;", dep.clname, dep.nsname, dep.clname);
} // fileCInterfaceSource


// ------------------------
// fileCInterfaceCommon
// ------------------------

void fileCInterfaceCommon(
   writer &hdr, writer &src,
   const InfoSpecs &specs,
   const PerClass &per, const Class2Dependencies &c2d
) {
   // Basics: create, assign, delete
   fileCInterfaceBasics(hdr,src, per);

   // IO: read, write, print
   fileCInterfaceIO(hdr,src, per);

   // Array support, if BlockData
   if (per.isDataVector)
      fileCInterfaceVector(hdr,src, per, per.elementType);

   // Functions regarding metadata
   for (const auto &m : per.metadata)
      fileCInterfaceMeta(hdr,src, per, m);

   // Functions regarding children
   for (const auto &c : per.children)
      fileCInterfaceChild(hdr,src, specs, per, c);

   // variants
   // todo
} // fileCInterfaceCommon


// ------------------------
// fileCInterface
// ------------------------

void fileCInterface(
   const InfoSpecs &specs, const PerClass &per, const Class2Dependencies &c2d
) {
   // header beginning
   writer hdr(per.headerC);
   fileCInterfaceHeader(hdr, specs, per, c2d);

   // source beginning
   writer src(per.sourceC);
   fileCInterfaceSource(src, specs, per, c2d);

   // common, or partially common, to both header and source
   fileCInterfaceCommon(hdr,src, specs, per, c2d);

   // header: customization #include, then done
   section(hdr, "// Custom functionality");
   hdr();
   hdr("#include \"@/@/@/src/custom.h\"",
       specs.Version, per.nsname, per.clname);
   hdr();
   hdr("#undef extern_c");
   hdr("#endif");

   // source: customization #include, then done
   section(src, "// Custom functionality");
   src();
   src("#include \"@/@/@/src/custom.cpp\"",
       specs.Version, per.nsname, per.clname);
} // fileCInterface


// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// For the Python interface
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// filePythonNamespace
// -----------------------------------------------------------------------------

void filePythonNamespace(const InfoSpecs &specs, const PerNamespace &per)
{
   writer out(per.cppPython);
   out();
   out("#include <pybind11/pybind11.h>");
   out("#include <pybind11/stl.h>");
   out("namespace py = pybind11;");
   out();
   out("// project @", specs.Project);
   out("// version @", specs.Version);
   out("namespace python_@ {", specs.Project);
   out("namespace python_@ {", specs.VersionUnderscore);

   out();
   out(1,"// namespace @: class wrapper declarations", per.nsname);
   out(1,"namespace python_@ {", per.nsname);
   for (const auto &cl : specs.ClassDependenciesSorted)
      if (cl.theClass.nsname == per.nsname)
         out(2,"void wrap@(py::module &);", cl.theClass.clname);
   out(1,"} // namespace python_@", per.nsname);

   out();
   out(1,"// namespace @: wrapper", per.nsname);
   out(1,"void wrap@(py::module &module)", capital(per.nsname));
   out(1,"{");
   out(2,"// @", per.nsname);
   out(2,"py::module submodule = module.def_submodule(");
   out(3,"\"@\",", per.nsname);
   if (specs.Project == "GNDStk")
      out(3,"\"GNDS @ @\"", specs.Version, per.nsname); // "GNDS", not "GNDStk"
   else
      out(3,"\"@ @ @\"", specs.Project, specs.Version, per.nsname);
   out(2,");");

   out();
   out(2,"// @ classes", per.nsname);
   for (const auto &cl : specs.ClassDependenciesSorted)
      if (cl.theClass.nsname == per.nsname)
         out(2,"python_@::wrap@(submodule);", per.nsname, cl.theClass.clname);
   out(1,"};");
   out();
   out("} // namespace python_@", specs.VersionUnderscore);
   out("} // namespace python_@", specs.Project);
} // filePythonNamespace


// -----------------------------------------------------------------------------
// filePythonClass
// -----------------------------------------------------------------------------

void filePythonClass(const InfoSpecs &specs, const PerClass &per)
{
   const std::string &nsname = per.nsname;
   const std::string &clname = per.clname;
   writer out(per.cppPython);

   std::vector<std::pair<std::string,std::string>> dataTypesNames;
   if (per.isDataVector) {
      // try to find per.elementType in nameMap
      auto it = nameMap.find(per.elementType);
      if (it != nameMap.end()) {
         // node has a fixed data type
         dataTypesNames.emplace_back(it->second.first, it->second.second);
      } else {
         // node has a runtime data type: select types to expose
         static std::array<std::string,3> types = { "int", "double", "string" };
         for (const auto &type : types) {
            it = nameMap.find(type);
            dataTypesNames.emplace_back(it->second.first, it->second.second);
         }
      }
   }

   // ------------------------
   // Begin file
   // ------------------------

   out();
   out("// system includes");
   out("#include <pybind11/pybind11.h>");
   out("#include <pybind11/stl.h>");

   out();
   out("// local includes");
   out("#include \"@/@/@/@.hpp\"",
       specs.Project, specs.Version, nsname, clname);
   out("#include \"definitions.hpp\"");

   out();
   out("// namespace aliases");
   out("namespace py = pybind11;");

   out();
   out("namespace python_@ {", specs.Project);
   out("namespace python_@ {", specs.VersionUnderscore);
   out("namespace python_@ {", nsname);

   out();
   out("// wrapper for @::@", nsname, clname);
   out("void wrap@(py::module &module)", clname);
   out("{");
   const std::string prefix = specs.Project == "GNDStk" ? "njoy::" : "";
   out(1,"using namespace @@;",
       prefix, specs.Project);
   out(1,"using namespace @@::@;",
       prefix, specs.Project, specs.VersionUnderscore);
   out();
   out(1,"// type aliases");
   out(1,"using cppCLASS = @::@;", nsname, clname);

   // using [variant name] = std::variant..., if necessary
   for (const auto &v : per.variants) {
      out(1,"using @ = std::variant<", v.type);
      int count = 0;
      const int total = v.children.size();
      for (const auto &c : v.children)
         out(2,"@@", c.type, sep(count,total));
      out(1,">;");
   }

   out();
   out(1,"// create the Python object");
   out(1,"py::class_<cppCLASS> object(");
   out(2,"module, \"@\",", clname);
   out(2,"cppCLASS::component_t::documentation().data()");
   out(1,");");

   // ------------------------
   // py::init<...>
   // for construction from
   // metadata and children
   // ------------------------

   int count = 0;
   const int total = per.nfields();

   out();
   out(1,"// constructor: from fields");
   out(1,"object.def(");
   out(2,"py::init<");
   {
      // init<> arguments
      for (const auto &m : per.metadata)
         out(3,"const @ &@",
             m.isDefaulted ? "std::optional<" + m.type + ">" : m.typeFull,
             sep(count,total));
      for (const auto &c : per.children)
         out(3,"const @ &@", c.typeFull, sep(count,total));
      for (const auto &v : per.variants)
         out(3,"const @ &@", v.typeFull, sep(count,total));
   }
   out(2,">(),");

   for (const auto &m : per.metadata)
      out(2,"py::arg(\"@\")@,",
          namePython(m.name),
          m.isOptional || m.isDefaulted ? " = std::nullopt" : "");
   for (const auto &c : per.children)
      out(2,"py::arg(\"@\")@,",
          namePython(c.name),
          c.isOptional ? " = std::nullopt" : "");
   for (const auto &v : per.variants)
      out(2,"py::arg(\"@\"),",
          namePython(v.name));
   out(2,"cppCLASS::component_t::documentation(\"constructor\").data()");
   out(1,");"); // object.def(

   // ------------------------
   // py::init<...>
   // for construction from
   // vector
   // ------------------------

   // vector type[s], as computed above
   for (const auto &dataTypeName : dataTypesNames) {
      out();
      out(1,"// constructor: from vector");
      out(1,"object.def(");
      out(2,"py::init<");
      out(3,"const std::vector<@> &", dataTypeName.first);
      out(2,">(),");
      out(2,"py::arg(\"@\"),", dataTypeName.second);
      out(2,"cppCLASS::component_t::documentation(\"constructor\").data()");
      out(1,");"); // object.def(
   }

   // ------------------------
   // def_property
   // metadata
   // ------------------------

   // todo
   // We need to ensure that what we're doing, below, works for optional,
   // Defaulted, and variant. (At the time of this writing, I'm not using
   // Defaulted or variant anywhere in the GNDS 2.0 specs.)

   for (const auto &m : per.metadata) {
      const auto pyname = namePython(m.name);
      out();
      out(1,"// get/set @", m.name);
      out(1,"object.def_property(");
      // name
      out(2,"\"@\",", pyname);
      // get
      out(2,"[](const cppCLASS &self) -> decltype(auto)");
      out(2,"{");
      m.isDefaulted
         ? out(3,"return self.@().value();", m.name)
         : out(3,"return self.@();", m.name);
      out(2,"},");
      // set
      m.isDefaulted
         ? out(2,"[](cppCLASS &self, const @ &value)", m.type)
         : out(2,"[](cppCLASS &self, const @ &value)", m.typeFull);
      out(2,"{");
      out(3,"self.@() = value;", m.name);
      out(2,"},");
      // documentation
      out(2,"cppCLASS::component_t::documentation(\"@\").data()", pyname);
      out(1,");");
   }

   // ------------------------
   // def_property
   // children
   // ------------------------

   for (const auto &c : per.children) {
      const auto pyname = namePython(c.name);
      out();
      out(1,"// get/set @", c.name);
      out(1,"object.def_property(");
      // name
      out(2,"\"@\",", pyname);
      // get
      out(2,"[](const cppCLASS &self) -> decltype(auto)");
      out(2,"{");
      out(3,"return self.@();", c.name);
      out(2,"},");
      // set
      out(2,"[](cppCLASS &self, const @ &value)", c.typeFull);
      out(2,"{");
      out(3,"self.@() = value;", c.name);
      out(2,"},");
      // documentation
      out(2,"cppCLASS::component_t::documentation(\"@\").data()", pyname);
      out(1,");");
   }

   // ------------------------
   // def_property
   // variants
   // ------------------------

   for (const auto &v : per.variants) {
      if (!v.isVector) {
         for (const auto &c : v.children) {
            const auto pyname = namePython(c.name);
            out();
            out(1,"object.def_property(");
            // name
            out(2,"\"@\",", pyname);
            // get
            out(2,"[](const cppCLASS &self) -> decltype(auto)");
            out(2,"{");
            out(3,"return self.@();", c.name);
            out(2,"},");
            // set
            out(2,"[](cppCLASS &self, const @ &value)", c.type);
            out(2,"{");
            out(3,"self.@() = value;", c.name);
            out(2,"},");
            // documentation
            out(2,"cppCLASS::component_t::documentation(\"@\").data()", pyname);
            out(1,");");
         }
      }
      const auto pyname = namePython(v.name);
      out();
      out(1,"object.def_property(");
      // name
      out(2,"\"@\",", pyname);
      // get
      out(2,"[](const cppCLASS &self) -> decltype(auto)");
      out(2,"{");
      out(3,"return self.@();", v.name);
      out(2,"},");
      // set
      out(2,"[](cppCLASS &self, const @ &value)", v.typeFull);
      out(2,"{");
      out(3,"self.@() = value;", v.name);
      out(2,"},");
      // documentation
      out(2,"cppCLASS::component_t::documentation(\"@\").data()", pyname);
      out(1,");");
   }

   // ------------------------
   // def_property
   // string
   // ------------------------

   if (per.isDataString) {
      out();
      out(1,"// get/set data string");
      out(1,"object.def_property(");
      out(2,"\"string\",");
      out(2,"[](const cppCLASS &self) -> const std::string &");
      out(2,"{");
      out(3,"return self;");
      out(2,"},");
      out(2,"[](cppCLASS &self, const std::string &value)");
      out(2,"{");
      out(3,"self = value;");
      out(2,"},");
      out(2,"cppCLASS::component_t::documentation(\"string\").data()");
      out(1,");");
   }

   // ------------------------
   // def_property
   // vector(s)
   // ------------------------

   for (const auto &dataTypeName : dataTypesNames) {
      out();
      out(1,"// get/set vector<@>", dataTypeName.first);
      out(1,"object.def_property(");
      // name
      out(2,"\"@\",", dataTypeName.second);
      // get
      out(2,"[](const cppCLASS &self) -> const std::vector<@> &",
          dataTypeName.first);
      out(2,"{");
      per.elementType == "" // vector is...
         ? out(3,"return self.@();", dataTypeName.second) // ...of dynamic type
         : out(3,"return self;"); // ...of a fixed type
      out(2,"},");
      // set
      out(2,"[](cppCLASS &self, const std::vector<@> &value)",
          dataTypeName.first);
      out(2,"{");
      per.elementType == "" // vector is...
         ? out(3,"self.@() = value;", dataTypeName.second) // ...of dynamic type
         : out(3,"self = value;"); // ...of a fixed type
      out(2,"},");
      // documentation
      out(2,"cppCLASS::component_t::documentation(\"@\").data()",
          dataTypeName.second);
      out(1,");");
   }

   // ------------------------
   // def_property
   // shortcuts
   // ------------------------

   for (const auto &cut : per.name2path) {
      const std::string &name = cut.first;
      const auto pyname = namePython(name);
      out();
      out(1,"// shortcut: get/set @", name);
      out(1,"object.def_property(");
      // name
      out(2,"\"@\",", pyname);
      // get
      out(2,"[](const cppCLASS &self) -> decltype(auto)");
      out(2,"{");
      out(3,"return self.@();", name);
      out(2,"},");
      // set
      // todo For the benefit of clarity both here and where the shortcut
      // references appear in the generated C++ classes, I suppose we should
      // determine the direct type of the referenced object. Note that it will
      // be some sort of Field<>, and, because Field<> is defined inside of
      // Component<> (intentionally so - see the remarks where class Field
      // is defined), we need to realize that Field<foo> inside a referencing
      // class will have a different meaning than Field<foo> in a referenced
      // context. We should think about ways to make this clearer in the code.
      out(2,"[](cppCLASS &self, const std::decay_t<decltype(self.@())> &value)",
          name);
      out(2,"{");
      out(3,"self.@() = value;", name);
      out(2,"},");
      // documentation
      out(2,"cppCLASS::component_t::documentation(\"@\").data()", pyname);
      out(1,");");
   }

   // ------------------------
   // finish
   // ------------------------

   out();
   out(1,"// add standard definitions");
   out(1,"addStandardComponentDefinitions<cppCLASS>(object);");
   out("}");

   out();
   out("} // namespace python_@", nsname);
   out("} // namespace python_@", specs.VersionUnderscore);
   out("} // namespace python_@", specs.Project);
} // filePythonClass


// -----------------------------------------------------------------------------
// ShortcutDown
// Helper for the shortcuts() function
// -----------------------------------------------------------------------------

void ShortcutDown(
   const InfoSpecs &specs,
   const InfoChildren &child,
   std::map<std::string,bool> &usednames,
   std::vector<std::string> &path,
   std::multimap<std::string,std::vector<std::string>> &name2path,
   std::set<std::string> &optvec,
   std::string &title, // might be modified
   int down,
   const bool warn,
   bool consider // <== we've *not* already gone through an optional or vector?
) {
   if (child.isOptional || child.isVector)
      consider = false; // at least henceforth, if not already

   const std::string &nsname = child.ns;
   const std::string &clname = child.plain;
   const auto it = specs.class2data.find(NamespaceAndClass(nsname,clname));
   if (it == specs.class2data.end()) {
      // We can't seem to find the namespace::class of the child object we're
      // looking at. This is probably more-or-less an error situation, at least
      // if somebody created all the children in their generated classes at the
      // same time that they created the parent - basically, meaning everything
      // was created in a single run of the code generator, which is how we
      // intend for it to be used. In any event: right here, in the present
      // context, we can't reason about shortcuts through the child if we can't
      // find any information *about* the child. So, we'll just return.
      return;
   }

   for (const auto &grand : it->second.children) {
      // grand: an InfoChildren
      const auto used = usednames.find(grand.name);
      if (used == usednames.end()) {
         if (consider) {
            // Create a preliminary shortcut, to be used later if, and only if,
            // nothing elsewhere introduces a name conflict. If something else
            // does, then we'll say, at that point, that the potential shortcut
            // is ambiguous. (It would probably create confusion if we somehow
            // chose one shortcut path over others, or tried to disambiguate by
            // inventing different names based on the same original name.)
            name2path.insert(std::make_pair(grand.name,path));
         } else {
            // We've gone through an optional or vector, and thus won't ever
            // be creating a shortcut to here. However, we'll record the fact
            // that something of this name exists, even if only through an
            // optional or vector, because such a scenario might be regarded
            // as a good reason to *not* shortcut to other same-named objects
            // that are otherwise valid for shurtcuts.
            optvec.insert(grand.name);
         }
      } else if (warn && !used->second) {
         std::cout
            << title << color::custom::faded::yellow
            << "   Shortcut would conflict with existing field: "
            << color::custom::yellow << grand.name
            << color::reset << std::endl;
         title = "";
         used->second = true; // so, don't report future conflicts w/same name
      }

      // Note that we always dig further, regardless of what happened with the
      // above conditionals. The current object might or might not, for whatever
      // reason or reasons, be something to which we could shortcut. However,
      // objects further down could potentially still be shortcut candidates,
      // or could prove to be deal breakers for other candidates.
      if (--down) {
         path.push_back(grand.name);
         ShortcutDown(
            specs, grand, usednames, path, name2path,
            optvec, title, down, warn, consider
         );
         path.pop_back();
      }
      down++;
   }
}


// -----------------------------------------------------------------------------
// shortcuts
// -----------------------------------------------------------------------------

void shortcuts(InfoSpecs &specs, int down, const bool warn)
{
   if (down == 1)
      return;

   // ------------------------
   // For each class
   // ------------------------

   for (auto &s : specs.class2data) {
      // s.first : a NamespaceAndClass
      // s.second: a PerClass, which we'll call "current" (the current class)

      // The following, title, simply tells us the namespace::class we're
      // currently examining. We'll arrange things so that it isn't printed
      // at all (thus reducing/decluttering the code generator's output) if
      // there's nothing to say - no shortcuts, no remarks about why some
      // shortcut potential didn't pan out. If anything *is* said, title is
      // printed and then set to "", so that it isn't needlessly re-printed.
      std::string title =
         color::custom::faded::purple + s.first.nsname + "::" +
         color::custom::purple + s.first.clname +
         color::reset + '\n';

      // ------------------------
      // Existing field names
      // in the current class
      // ------------------------

      // The bool is for diagnostic reporting, if we want to report only
      // once, per name, about potential shortcut(s) conflicting with it.
      std::map<std::string,bool> usednames;

      // comment; all of our generated classes have this
      usednames.insert(std::make_pair("comment",false));

      // metadata, children, variants
      PerClass &current = s.second;
      for (const auto &m : current.metadata)
         usednames.insert(std::make_pair(m.name,false));
      for (const auto &c : current.children)
         usednames.insert(std::make_pair(c.name,false));
      for (const auto &v : current.variants)
         usednames.insert(std::make_pair(v.name,false));

      // data (string or vector)
      if (current.isDataNode) {
         if (current.isDataString)
            usednames.insert(std::make_pair("string",false));
         else {
            // As in some other new(er) code-generator capabilities, I haven't
            // handled the GNDS valueType (basically, dynamic data type) stuff
            // here because it's inherently a messy concept and we may be able
            // to avoid the need for it. (But possibly todo.)
            auto it = nameMap.find(current.elementType);
            if (it != nameMap.end())
               usednames.insert(std::make_pair(it->second.second,false));
         }
      }

      // ------------------------
      // Visit children
      // ------------------------

      // For each object to which a shortcut may be possible (to be determined,
      // based on criteria such as uniqueness), we'll have a map key:value pair.
      // The key is the name of the object to which we may shortcut. The value
      // is a vector of names, giving the path to the object. Example: say that
      // the current class has x, which has y, which has foo. The potential foo
      // shortcut would be represented by map key "foo", value {"x","y"}. Note
      // that we use a multimap, because something might appear via multiple
      // viable paths - without going through any optional, vector, or variant.
      // An object of the same name being in multiple paths may mean that we
      // won't shortcut to any of them (unless we decide on a reasonable way
      // to disambiguate), but we can still use the multimap we'll be computing
      // to print informational messages telling users about multuple paths.
      std::multimap<std::string, std::vector<std::string>> name2path;

      // The above will contain key:value pairs for objects that appear to be
      // valid for shortcutting - they don't go through optionals or vectors -
      // except potentially for ambiguities. We'll also maintain (separately,
      // as doing so is cleaner) a set of names that appear through optionals
      // and/or vectors. We won't need paths here, as we'd never be using them,
      // and also don't need to record names more than once for our purposes
      // here (hence a plain set). This set can be used to exclude otherwise
      // valid and unambiguous shortcuts, if we regard the existence of another
      // object of the same name - even under an optional or a vector - to have
      // introduced an ambiguity. todo: Consider variants here too!
      std::set<std::string> optvec;

      // Each "child" in the following is of class InfoChildren
      for (const auto &child : current.children) {
         // Path down which we're shortcutting
         std::vector<std::string> path;
         path.push_back(child.name);

         // The "true" in the following call means we haven't already gone
         // through an optional or vector. Which of course we haven't - at
         // this point, because this is the initial call into the recursion.
         down--;
         ShortcutDown(
            specs, child, usednames, path, name2path,
            optvec, title, down, warn, true
         );
         down++;
      }

      // ------------------------
      // Identify unique
      // shortcuts
      // ------------------------

      using namespace color;
      std::set<std::string> reportedAlready;

      // For each potential shortcut as determined above...
      for (const auto &cut : name2path) {
         const std::string &name = cut.first;
         const std::vector<std::string> &path = cut.second;

         // If a shortcut of this name would be ambiguous directly - because
         // another otherwise viable shortcut of the same name exists - then
         // report on this. We arrange to do the reporting just once.
         if (name2path.count(name) > 1) {
            if (warn && reportedAlready.find(name) == reportedAlready.end()) {
               std::cout
                  << title << "   " << custom::faded::yellow
                  << "Shortcut would be ambiguous: "
                  << custom::yellow << name << reset << std::endl;
               title = "";

               auto one = name2path.lower_bound(name);
               auto end = name2path.upper_bound(name);
               while (one != end) {
                  std::cout << "      " << custom::faded::yellow;
                  for (const std::string &field : one->second)
                     std::cout << field << '.';
                  std::cout << custom::yellow << name << reset << std::endl;
                  one++;
               }

               // So we don't print the above message again, for the duplicates
               reportedAlready.insert(name);
            }
            continue;
         }

         // If a shortcut of this name *could* be considered ambiguous because
         // the same name also exists beyond an optional or a vector, then the
         // following code excludes it from being made into a shortcut. We may
         // or may not want to have this condition. Todo: decide on this.
         if (optvec.find(name) != optvec.end()) {
            if (warn && reportedAlready.find(name) == reportedAlready.end()) {
               std::cout
                  << title << "   " << custom::faded::yellow
                  << "Shortcut would be ambiguous vis-à-vis optional/vector: "
                  << custom::yellow << name << reset << std::endl;
               title = "";
               reportedAlready.insert(name);
            }
            continue;
         }

         // Shortcut!
         std::cout << title << custom::blue << "   Shortcut: " << custom::green;
         title = "";
         for (const std::string &field : path)
            std::cout << field << '.';
         std::cout << custom::red << name << reset << std::endl;

         // Remember this shortcut. We'll use it soon,
         // when writing code for the current class.
         current.name2path.insert(cut);
      }
   } // each class in which we're looking for shortcuts
}


// -----------------------------------------------------------------------------
// main
// -----------------------------------------------------------------------------

int main(const int argc, const char *const *const argv)
{
   // For GNDStk's diagnostics
   colors = true;

   // ------------------------
   // Read .json
   // ------------------------

   // READ INFORMATION from the JSON file on the command line
   action(
      "GNDStk Code Generator",
      "Author: Martin Staley",
      "Los Alamos National Laboratory"
   );
   InfoSpecs specs;
   commandLine(argc, argv, specs);

   // ------------------------
   // Simplifications?
   // ------------------------

   // REPORT regarding potential simplifications
   if (singletons) {
      action("Finding Potential Simplifications");
      for (const std::string &file : specs.JSONFiles)
         printSingletons(file);
   }

   // ------------------------
   // Preprocessing
   // ------------------------

   // PREPROCESS, to get information needed upfront for detailed processing
   action("Preprocessing");
   preprocessFiles(specs);
   getFilesAndClasses(specs);

   // COMPUTE AN ORDERING that respects dependencies
   sortDependencies(specs);

   // ------------------------
   // Shortcuts
   // ------------------------

   // COMPUTE SHORTCUTS
   // The boolean tells us whether or not the code should print information
   // about potential shortcuts that end up being unused for whatever reason.
   // I suppose this should eventually be a command-line argument.
   const int levelsDown = argc >= 3 ? atoi(argv[2]) : ShortcutLevels;
   if (levelsDown != 1)
      action("Computing Shortcuts");
   shortcuts(specs, levelsDown, false);

   // ------------------------
   // C++
   // ------------------------

   // PRINT CLASS CODE into temporary strings, which are written to the
   // class-specific files later, after class dependencies are computed
   action("Writing Code: C++");
   for (auto &c : specs.class2data) {
      const std::string &nsname = c.first.nsname;
      const std::string &clname = c.first.clname;
      std::string title =
         color::custom::faded::purple + nsname + "::" +
         color::custom::purple + clname + color::reset + '\n';
      PerClass &per = c.second;
      // after the following, per.code will contain printed
      // C++ code for the class itself
      writeClass(specs, title, per, per.code);
   }

   // Create GNDStk hpp file for this GNDS version
   fileGNDStkVersion(specs);

   // Create GNDStk hpp file for Meta and Child keys
   fileGNDStkKey(specs);

   // For each namespace::class: create GNDStk hpp file
   for (const auto &obj : specs.ClassDependenciesSorted)
      fileGNDStkClass(specs, specs.class2data.find(obj.theClass)->second, obj);

   // ------------------------
   // C Interface
   // ------------------------

   // For each namespace::class: create header+source files for the C interface
   action("Writing Code: C Interface");
   for (const auto &obj : specs.ClassDependenciesSorted)
      fileCInterface(specs, specs.class2data.find(obj.theClass)->second, obj);

   // ------------------------
   // Python Interface
   // ------------------------

   // Create Python cpp file for each namespace
   // Create Python cpp file for each namespace::class
   action("Writing Code: Python Interface");
   for (const auto &obj : specs.namespace2data)
      filePythonNamespace(specs, obj.second);
   for (const auto &obj : specs.class2data)
      filePythonClass(specs, obj.second);
   std::cout << std::endl;
}
