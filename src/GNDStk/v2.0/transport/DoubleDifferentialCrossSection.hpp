
// THIS FILE WAS AUTOGENERATED!
// DO NOT MODIFY!

#ifndef NJOY_GNDSTK_V2_0_TRANSPORT_DOUBLEDIFFERENTIALCROSSSECTION
#define NJOY_GNDSTK_V2_0_TRANSPORT_DOUBLEDIFFERENTIALCROSSSECTION

// core interface
#include "GNDStk.hpp"

// v2.0 dependencies
#include "GNDStk/v2.0/cpTransport/CoulombPlusNuclearElastic.hpp"
#include "GNDStk/v2.0/containers/XYs3d.hpp"
#include "GNDStk/v2.0/atomic/CoherentPhotonScattering.hpp"
#include "GNDStk/v2.0/atomic/IncoherentPhotonScattering.hpp"
#include "GNDStk/v2.0/transport/Reference.hpp"
#include "GNDStk/v2.0/containers/Regions3d.hpp"
#include "GNDStk/v2.0/tsl/ThermalNeutronScatteringLaw_coherentElastic.hpp"
#include "GNDStk/v2.0/tsl/ThermalNeutronScatteringLaw_incoherentElastic.hpp"
#include "GNDStk/v2.0/tsl/ThermalNeutronScatteringLaw_incoherentInelastic.hpp"

namespace njoy {
namespace GNDStk {
namespace v2_0 {

using namespace njoy::GNDStk::core;



// -----------------------------------------------------------------------------
// transport::
// class DoubleDifferentialCrossSection
// -----------------------------------------------------------------------------

namespace transport {

class DoubleDifferentialCrossSection : public Component<DoubleDifferentialCrossSection> {


   // ------------------------
   // For Component
   // ------------------------

   friend class Component;

   // Current namespace, current class, and GNDS node name
   static auto namespaceName() { return "transport"; }
   static auto className() { return "DoubleDifferentialCrossSection"; }
   static auto GNDSName() { return "doubleDifferentialCrossSection"; }

   // Core Interface multi-query to extract metadata and child nodes
   static auto keys()
   {
      return
         // children
         std::optional<cpTransport::CoulombPlusNuclearElastic>{}
            / --Child<>("CoulombPlusNuclearElastic") |
         std::optional<containers::XYs3d>{}
            / --Child<>("XYs3d") |
         std::optional<atomic::CoherentPhotonScattering>{}
            / --Child<>("coherentPhotonScattering") |
         std::optional<atomic::IncoherentPhotonScattering>{}
            / --Child<>("incoherentPhotonScattering") |
         std::optional<transport::Reference>{}
            / --Child<>("reference") |
         std::optional<containers::Regions3d>{}
            / --Child<>("regions3d") |
         std::optional<tsl::ThermalNeutronScatteringLaw_coherentElastic>{}
            / --Child<>("thermalNeutronScatteringLaw_coherentElastic") |
         std::optional<tsl::ThermalNeutronScatteringLaw_incoherentElastic>{}
            / --Child<>("thermalNeutronScatteringLaw_incoherentElastic") |
         std::optional<tsl::ThermalNeutronScatteringLaw_incoherentInelastic>{}
            / --Child<>("thermalNeutronScatteringLaw_incoherentInelastic")
      ;
   }

public:

   using Component::construct;

   // ------------------------
   // Relevant defaults
   // FYI for users
   // ------------------------

   static inline const struct Defaults {
   } defaults;

   // ------------------------
   // Raw GNDS content
   // ------------------------

   struct {
      // children
      std::optional<cpTransport::CoulombPlusNuclearElastic> CoulombPlusNuclearElastic;
      std::optional<containers::XYs3d> XYs3d;
      std::optional<atomic::CoherentPhotonScattering> coherentPhotonScattering;
      std::optional<atomic::IncoherentPhotonScattering> incoherentPhotonScattering;
      std::optional<transport::Reference> reference;
      std::optional<containers::Regions3d> regions3d;
      std::optional<tsl::ThermalNeutronScatteringLaw_coherentElastic> thermalNeutronScatteringLaw_coherentElastic;
      std::optional<tsl::ThermalNeutronScatteringLaw_incoherentElastic> thermalNeutronScatteringLaw_incoherentElastic;
      std::optional<tsl::ThermalNeutronScatteringLaw_incoherentInelastic> thermalNeutronScatteringLaw_incoherentInelastic;
   } content;

   // ------------------------
   // Getters
   // const and non-const
   // ------------------------

   // CoulombPlusNuclearElastic
   const std::optional<cpTransport::CoulombPlusNuclearElastic> &CoulombPlusNuclearElastic() const
      { return content.CoulombPlusNuclearElastic; }
   std::optional<cpTransport::CoulombPlusNuclearElastic> &CoulombPlusNuclearElastic()
      { return content.CoulombPlusNuclearElastic; }

   // XYs3d
   const std::optional<containers::XYs3d> &XYs3d() const
      { return content.XYs3d; }
   std::optional<containers::XYs3d> &XYs3d()
      { return content.XYs3d; }

   // coherentPhotonScattering
   const std::optional<atomic::CoherentPhotonScattering> &coherentPhotonScattering() const
      { return content.coherentPhotonScattering; }
   std::optional<atomic::CoherentPhotonScattering> &coherentPhotonScattering()
      { return content.coherentPhotonScattering; }

   // incoherentPhotonScattering
   const std::optional<atomic::IncoherentPhotonScattering> &incoherentPhotonScattering() const
      { return content.incoherentPhotonScattering; }
   std::optional<atomic::IncoherentPhotonScattering> &incoherentPhotonScattering()
      { return content.incoherentPhotonScattering; }

   // reference
   const std::optional<transport::Reference> &reference() const
      { return content.reference; }
   std::optional<transport::Reference> &reference()
      { return content.reference; }

   // regions3d
   const std::optional<containers::Regions3d> &regions3d() const
      { return content.regions3d; }
   std::optional<containers::Regions3d> &regions3d()
      { return content.regions3d; }

   // thermalNeutronScatteringLaw_coherentElastic
   const std::optional<tsl::ThermalNeutronScatteringLaw_coherentElastic> &thermalNeutronScatteringLaw_coherentElastic() const
      { return content.thermalNeutronScatteringLaw_coherentElastic; }
   std::optional<tsl::ThermalNeutronScatteringLaw_coherentElastic> &thermalNeutronScatteringLaw_coherentElastic()
      { return content.thermalNeutronScatteringLaw_coherentElastic; }

   // thermalNeutronScatteringLaw_incoherentElastic
   const std::optional<tsl::ThermalNeutronScatteringLaw_incoherentElastic> &thermalNeutronScatteringLaw_incoherentElastic() const
      { return content.thermalNeutronScatteringLaw_incoherentElastic; }
   std::optional<tsl::ThermalNeutronScatteringLaw_incoherentElastic> &thermalNeutronScatteringLaw_incoherentElastic()
      { return content.thermalNeutronScatteringLaw_incoherentElastic; }

   // thermalNeutronScatteringLaw_incoherentInelastic
   const std::optional<tsl::ThermalNeutronScatteringLaw_incoherentInelastic> &thermalNeutronScatteringLaw_incoherentInelastic() const
      { return content.thermalNeutronScatteringLaw_incoherentInelastic; }
   std::optional<tsl::ThermalNeutronScatteringLaw_incoherentInelastic> &thermalNeutronScatteringLaw_incoherentInelastic()
      { return content.thermalNeutronScatteringLaw_incoherentInelastic; }

   // ------------------------
   // Setters
   // non-const
   // All return *this
   // ------------------------

   // CoulombPlusNuclearElastic(value)
   DoubleDifferentialCrossSection &CoulombPlusNuclearElastic(const std::optional<cpTransport::CoulombPlusNuclearElastic> &obj)
      { CoulombPlusNuclearElastic() = obj; return *this; }

   // XYs3d(value)
   DoubleDifferentialCrossSection &XYs3d(const std::optional<containers::XYs3d> &obj)
      { XYs3d() = obj; return *this; }

   // coherentPhotonScattering(value)
   DoubleDifferentialCrossSection &coherentPhotonScattering(const std::optional<atomic::CoherentPhotonScattering> &obj)
      { coherentPhotonScattering() = obj; return *this; }

   // incoherentPhotonScattering(value)
   DoubleDifferentialCrossSection &incoherentPhotonScattering(const std::optional<atomic::IncoherentPhotonScattering> &obj)
      { incoherentPhotonScattering() = obj; return *this; }

   // reference(value)
   DoubleDifferentialCrossSection &reference(const std::optional<transport::Reference> &obj)
      { reference() = obj; return *this; }

   // regions3d(value)
   DoubleDifferentialCrossSection &regions3d(const std::optional<containers::Regions3d> &obj)
      { regions3d() = obj; return *this; }

   // thermalNeutronScatteringLaw_coherentElastic(value)
   DoubleDifferentialCrossSection &thermalNeutronScatteringLaw_coherentElastic(const std::optional<tsl::ThermalNeutronScatteringLaw_coherentElastic> &obj)
      { thermalNeutronScatteringLaw_coherentElastic() = obj; return *this; }

   // thermalNeutronScatteringLaw_incoherentElastic(value)
   DoubleDifferentialCrossSection &thermalNeutronScatteringLaw_incoherentElastic(const std::optional<tsl::ThermalNeutronScatteringLaw_incoherentElastic> &obj)
      { thermalNeutronScatteringLaw_incoherentElastic() = obj; return *this; }

   // thermalNeutronScatteringLaw_incoherentInelastic(value)
   DoubleDifferentialCrossSection &thermalNeutronScatteringLaw_incoherentInelastic(const std::optional<tsl::ThermalNeutronScatteringLaw_incoherentInelastic> &obj)
      { thermalNeutronScatteringLaw_incoherentInelastic() = obj; return *this; }

   // ------------------------
   // Construction
   // ------------------------

   // default
   DoubleDifferentialCrossSection() :
      Component{
         BodyText{},
         content.CoulombPlusNuclearElastic,
         content.XYs3d,
         content.coherentPhotonScattering,
         content.incoherentPhotonScattering,
         content.reference,
         content.regions3d,
         content.thermalNeutronScatteringLaw_coherentElastic,
         content.thermalNeutronScatteringLaw_incoherentElastic,
         content.thermalNeutronScatteringLaw_incoherentInelastic
      }
   {
      Component::finish();
   }

   // copy
   DoubleDifferentialCrossSection(const DoubleDifferentialCrossSection &other) :
      Component{
         other,
         content.CoulombPlusNuclearElastic,
         content.XYs3d,
         content.coherentPhotonScattering,
         content.incoherentPhotonScattering,
         content.reference,
         content.regions3d,
         content.thermalNeutronScatteringLaw_coherentElastic,
         content.thermalNeutronScatteringLaw_incoherentElastic,
         content.thermalNeutronScatteringLaw_incoherentInelastic
      },
      content{other.content}
   {
      Component::finish(other);
   }

   // move
   DoubleDifferentialCrossSection(DoubleDifferentialCrossSection &&other) :
      Component{
         other,
         content.CoulombPlusNuclearElastic,
         content.XYs3d,
         content.coherentPhotonScattering,
         content.incoherentPhotonScattering,
         content.reference,
         content.regions3d,
         content.thermalNeutronScatteringLaw_coherentElastic,
         content.thermalNeutronScatteringLaw_incoherentElastic,
         content.thermalNeutronScatteringLaw_incoherentInelastic
      },
      content{std::move(other.content)}
   {
      Component::finish(other);
   }

   // from node
   DoubleDifferentialCrossSection(const Node &node) :
      Component{
         BodyText{},
         content.CoulombPlusNuclearElastic,
         content.XYs3d,
         content.coherentPhotonScattering,
         content.incoherentPhotonScattering,
         content.reference,
         content.regions3d,
         content.thermalNeutronScatteringLaw_coherentElastic,
         content.thermalNeutronScatteringLaw_incoherentElastic,
         content.thermalNeutronScatteringLaw_incoherentInelastic
      }
   {
      Component::finish(node);
   }

   // from fields
   explicit DoubleDifferentialCrossSection(
      const std::optional<cpTransport::CoulombPlusNuclearElastic> &CoulombPlusNuclearElastic,
      const std::optional<containers::XYs3d> &XYs3d,
      const std::optional<atomic::CoherentPhotonScattering> &coherentPhotonScattering,
      const std::optional<atomic::IncoherentPhotonScattering> &incoherentPhotonScattering,
      const std::optional<transport::Reference> &reference,
      const std::optional<containers::Regions3d> &regions3d,
      const std::optional<tsl::ThermalNeutronScatteringLaw_coherentElastic> &thermalNeutronScatteringLaw_coherentElastic,
      const std::optional<tsl::ThermalNeutronScatteringLaw_incoherentElastic> &thermalNeutronScatteringLaw_incoherentElastic,
      const std::optional<tsl::ThermalNeutronScatteringLaw_incoherentInelastic> &thermalNeutronScatteringLaw_incoherentInelastic
   ) :
      Component{
         BodyText{},
         content.CoulombPlusNuclearElastic,
         content.XYs3d,
         content.coherentPhotonScattering,
         content.incoherentPhotonScattering,
         content.reference,
         content.regions3d,
         content.thermalNeutronScatteringLaw_coherentElastic,
         content.thermalNeutronScatteringLaw_incoherentElastic,
         content.thermalNeutronScatteringLaw_incoherentInelastic
      },
      content{
         CoulombPlusNuclearElastic,
         XYs3d,
         coherentPhotonScattering,
         incoherentPhotonScattering,
         reference,
         regions3d,
         thermalNeutronScatteringLaw_coherentElastic,
         thermalNeutronScatteringLaw_incoherentElastic,
         thermalNeutronScatteringLaw_incoherentInelastic
      }
   {
      Component::finish();
   }

   // ------------------------
   // Assignment
   // ------------------------

   // copy
   DoubleDifferentialCrossSection &operator=(const DoubleDifferentialCrossSection &) = default;

   // move
   DoubleDifferentialCrossSection &operator=(DoubleDifferentialCrossSection &&) = default;

   // ------------------------
   // Custom functionality
   // ------------------------

   #include "GNDStk/v2.0/transport/DoubleDifferentialCrossSection/src/custom.hpp"

}; // class DoubleDifferentialCrossSection

} // namespace transport
} // namespace v2_0
} // namespace GNDStk
} // namespace njoy

#endif
