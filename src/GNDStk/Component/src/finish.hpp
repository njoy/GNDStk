
// -----------------------------------------------------------------------------
// finish() functions
// DESCRIPTION
// -----------------------------------------------------------------------------

/*
These accomplish two goals.

1. Some perform actions that depend on derived-class data that can't be assumed
to have been initialized, or even in a valid form in memory, before the *body*
of the derived class has been entered. (Think in terms of initialization order
in derived-class constructors. Base classes are initialized first.) Our code
autogeneration tool arranges for autogenerated derived-class constructors each
to call one of the finish() functions below, so that the additional necessary
work can be done. Anyone who directly writes classes derived from Component is
advised to call a finish() as well, or to achieve the necessary effect in some
other manner.

2. These also provide a means by which derived-class constructors that are built
by our autogeneration tool can run additional code that someone's customization
of the autogenerated class might need.

The second thing is achieved in the following way. Autogenerated constructors
each call one of the finish() functions. Each finish() function first does what
it needs to do, then attempts to call a "DERIVED::construct()" function with the
same signature as the calling finish(). Derived-class custom code can provide
such a construct(), and thereby have its code be run. If a derived class doesn't
have such a construct(), then DERIVED::construct() ends up going to one of our
stub construct() functions here, in the Component base class. A derived class
thus can, but does not need to, provide a construct().

Arguments are received where (1) the derived-class constructor receives the
argument, but (2) the argument is transitory - it's used in the constructor,
but it doesn't go into the autogenerated "content" struct in the derived class.
(If it did go into the content struct, we'd simply extract it from there instead
of having finish() receive it as a parameter.)

Specifically, the constructors in the auto-generated classes call:

   Default constructor:
      Component::finish()

   Copy and move constructors:
      Component::finish(other)
      Where other is the incoming object that's being copied or moved.

   Constructor from a Node:
      Component::finish(the Node)

   Constructors involving a vector<T> of "body text" data:
      Component::finish(the vector)

Note: In the last case, we're speaking of a vector<T> that's specifically for
body text, not a vector<T> that might be there for a different reason.
*/



// -----------------------------------------------------------------------------
// construct() stubs
// Override in a derived-class customization, to have custom code be run.
// Cases: (), (DERIVED), (Node), (vector)
// -----------------------------------------------------------------------------

void construct() { }
void construct(const DERIVED &) { }
void construct(const Node &) { }

template<
   class VECTOR,
   class = std::enable_if_t<
      hasBodyText && detail::isAlternative<VECTOR,VariantOfVectors>
   >
>
void construct(const VECTOR &) { }



// -----------------------------------------------------------------------------
// finish() functions
// -----------------------------------------------------------------------------

// finish()
void finish()
{
   // If hasBodyText == true (else no-op), have Component's BodyText base
   // get length, start, and valueType, as available, from the derived class
   body::pullFromDerived(derived().content);

   // construct
   derived().construct();
}


// finish(DERIVED)
void finish(const DERIVED &other)
{
   // length, start, valueType
   body::pullFromDerived(derived().content);

   // construct
   void (Component::*stub)(const DERIVED &) = &Component::construct;
   void (DERIVED::*custom)(const DERIVED &) = &DERIVED::construct;
   if (custom != stub)
      derived().construct(other);
   else
      derived().construct();
}


// finish(Node)
void finish(const Node &node)
{
   // Read fields from the Node into the derived object. This applies the keys()
   // multi-query in the derived class, and also runs BodyText::fromNode(),
   // which gets the Node's raw string of "body text" if the Node has body text.
   fromNode(node);

   // length, start, valueType
   body::pullFromDerived(derived().content);

   // Make vector
   if constexpr (hasBodyText)
      body::get();

   // construct
   void (Component::*stub)(const Node &) = &Component::construct;
   void (DERIVED::*custom)(const Node &) = &DERIVED::construct;
   if (custom != stub)
      derived().construct(node);
   else
      derived().construct();
}


// finish(vector)
template<
   class VECTOR,
   class = std::enable_if_t<
      hasBodyText &&
      detail::isAlternative<VECTOR,VariantOfVectors>
   >
>
void finish(const VECTOR &values)
{
   // length, start, valueType
   body::pullFromDerived(derived().content);

   // Assign from the vector
   body::operator=(values);

   // construct
   void (Component::*stub)(const VECTOR &) = &Component::construct;
   void (DERIVED::*custom)(const VECTOR &) = &DERIVED::construct;
   if (custom != stub)
      derived().construct(values);
   else
      derived().construct();
}
